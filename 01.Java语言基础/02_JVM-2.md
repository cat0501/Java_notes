



# 🎈🎈🎈《Offer来了》JVM部分



# 1 JVM的运行机制

JVM（Java Virtual Machine）是用于运行Java字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。JVM运行在操作系统之上，不与硬件设备直接交互。



<br>

Java程序的具体运行过程如下。

- Java源文件被编译器编译成**字节码文件**。
- JVM将字节码文件编译成**相应操作系统的机器码**。

- 机器码调用相应操作系统的**本地方法库执行相应的方法**。

 Java虚拟机如图所示：

![](https://notes2021.oss-cn-beijing.aliyuncs.com/2021/image-20220602114435239.png)



其中：

- 类加载器子系统：用于将编译好的.Class文件加载到JVM中；

- 运行时数据区：用于存储在JVM运行过程中产生的数据，包括程序计数器、方法区、本地方法区、虚拟机栈和虚拟机堆；

- 执行引擎包括即时编译器和垃圾回收器：即时编译器用于将Java字节码编译成具体的机器码，垃圾回收器用于回收在运行过程中不再使用的对象；

- 本地接口库用于调用操作系统的本地方法库完成具体的指令操作。



# 2 所谓多线程

在多核操作系统上，JVM允许在一个进程内同时并发执行多个线程。





# 3 JVM的内存区域

JVM的内存区域分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（堆、方法区）和直接内存，如图所示。



线程私有区域的生命周期与线程相同，随线程的启动而创建，随线程的结束而销毁。

线程共享区域随虚拟机的启动而创建，随虚拟机的关闭而销毁。



## 3.1 程序计数器：线程私有，无内存溢出问题

程序计数器是一块很小的内存空间，用于存储当前运行的线程所执行的字节码的行号指示器。

程序计数器属于“线程私有”的内存区域，它是唯一没有Out Of Memory（内存溢出）的区域。

## 3.2 虚拟机栈：线程私有，描述**Java**方法的执行过程

栈帧用来记录方法的执行过程，在方法被执行时虚拟机会为其创建一个与之对应的栈帧，方法的执行和返回对应栈帧在虚拟机栈中的入栈和出栈。无论方法是正常运行完成还是异常完成（抛出了在方法内未被捕获的异常），都视为方法运行结束。

每个运行中的线程当前只有一个栈帧处于活动状态。

## 3.3 本地方法区：线程私有

本地方法区和虚拟机栈的作用类似，区别是虚拟机栈为执行Java方法服务，本地方法栈为Native方法服务。

## 3.4 堆：也叫作运行时数据区，线程共享

在JVM运行过程中**创建的对象和产生的数据**都被存储在堆中，堆是被**线程共享的内存区域**，也是**垃圾收集器进行垃圾回收的最主要的内存**

**区域**。

由于现代JVM采用**分代收集算法** ，因此Java堆从GC（GarbageCollection，垃圾回收）的角度还可以细分为：**新生代、老年代和永久代**。

## 3.5 方法区：线程共享

方法区也被称为永久代，用于**存储常量、静态变量、类信息、即时编译器编译后的机器码、运行时常量池等**数据







# 4 JVM的运行时内存（新生代+老年代+永久代）

JVM的运行时内存也叫作JVM堆，从GC的角度可以将JVM堆分为新生代、老年代和永久代。

- 其中新生代默认占 1/3堆空间，老年代默认占2/3堆空间，永久代占非常少的堆空间。

- 新生代又分为Eden区、ServivorFrom区和ServivorTo区，Eden区默认占8/10新生代空间，ServivorFrom区和ServivorTo区默认分别占 1/10新生代空间，

## 4.1 新生代：Eden**区、**ServivorTo**区和**ServivorFrom区（MinorGC）

JVM新创建的对象（除了大对象外）会被存放在新生代。

由于JVM会频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。

### Eden区

- Java新创建的对象首先会被存放在Eden区，如果新创建的对象属于大对象，则直接将其分配到老年代。
  - 大对象的定义和具体的JVM版本、堆大小和垃圾回收策略有关，一般为 2KB～128KB，可通过XX:PretenureSizeThreshold设置其大小。
- 在Eden区的内存空间不足时会触发MinorGC，对新生代进行一次垃圾回收。

### ServivorTo区

- 保留上一次MinorGC时的幸存者。

### ServivorFrom区

- 将上一次MinorGC时的幸存者作为这一次MinorGC的被扫描者。

<br>

新生代的GC过程叫作MinorGC，采用复制算法实现，具体过程如下。

（1）把在Eden区和ServivorFrom区中存活的对象**复制到ServivorTo区**。出现如下情况则将其复制到老年代：

- 如果某对象的年龄达到老年代的标准（对象晋升老年代的标准由XX:MaxTenuringThreshold设置，默认为 15）

- 如果ServivorTo区的内存空间不够
- 如果对象属于大对象（大小为 2KB～128KB的对象属于大对象，例如通过XX:PretenureSizeThreshold=2097152设置大对象为 2MB，1024×1024×2Byte=2097152Byte=2MB）

（2）**清空Eden区和ServivorFrom区**中的对象。

（3）将ServivorTo区和ServivorFrom区互换，原来的ServivorTo区成为下一次GC时的ServivorFrom区。

## 4.2 老年代（存放有长生命周期的对象和大对象）（MajorGC + 标记清除算法）

老年代主要存放有长生命周期的对象和大对象。

<br>

老年代的GC过程叫作MajorGC。在老年代，对象比较稳定，MajorGC不会被频繁触发。

在进行MajorGC前，**JVM会先进行一次MinorGC**，在MinorGC过后仍然出现老年代空间不足或无法找到足够大的连续空间分配给新创建的大对象时，会触发MajorGC进行垃圾回收，释放JVM的内存空间。

<br>

MajorGC采用标记清除算法，该算法首先会扫描所有对象并标记存活的对象，然后回收未被标记的对象，并释放内存空间。

因为要先扫描老年代的所有对象再回收，所以MajorGC的耗时较长。MajorGC的标记清除算法容易产生内存碎片。在老年代没有内存空间可分配时，会抛出Out Of Memory异常。

## 4.3 永久代



需要注意的是，在Java 8中永久代已经被元数据区（也叫作元空间）取代。元数据区的作用和永久代类似，二者最大的区别在于：元数据区并没有使用虚拟机的内存，而是直接使用操作系统的本地内存。因此，元空间的大小不受JVM内存的限制，只和操作系统的内存有关。









# 5 垃圾回收与算法



## 5.1 如何确定垃圾

Java采用引用计数法和可达性分析来确定对象是否应该被回收。

### （1）引用计数法

在Java中如果要操作对象，就必须先获取该对象的引用，因此可以通过引用计数法来判断一个对象是否可以被回收。

在为对象添加一个引用时，引用计数加 1；在为对象删除一个引用时，引进计数减 1；如果一个对象的引用计数为 0，则表示此刻该对象没有被引用，可以被回收。

<br>

引用计数法容易产生循环引用问题。循环引用指两个对象相互引用，导致它们的引用一直存在，而不能被回收





### （2）可达性分析

为了解决引用计数法的循环引用问题，Java还采用了可达性分析来判断对象是否可以被回收。

- 不可达
  - 首先定义一些GC Roots对象，然后以这些GC Roots对象作为起点向下搜索，如果在GC roots和一个对象之间没有可达路径，则称该对象是不可达的。

- 两次标记
  - 不可达对象要经过至少两次标记才能判定其是否可以被回收，如果在两次标记后该对象仍然是不可达的，则将被垃圾收集器回收。

## 5.2 Java中常用的4种垃圾回收算法

### （1）标记清除算法（快、但是存在碎片）

![](https://java-notes-1308812086.cos.ap-beijing.myqcloud.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png)





### （2）复制算法（无碎片、但要占用双倍内存空间）⭐️

![](https://notes2021.oss-cn-beijing.aliyuncs.com/2021/image-20220602144728807.png)



### （3）标记整理算法（慢、无碎片）⭐️

![](https://notes2021.oss-cn-beijing.aliyuncs.com/2021/image-20220602144658366.png)



### （4）分代收集算法

![](https://notes2021.oss-cn-beijing.aliyuncs.com/2021/image-20220602144758693.png)

- 对象首先分配在伊甸园区域
- 新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to

- minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

- 当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）

- 当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长



# 6 Java中的4种引用类型

在Java中一切皆对象，对象的操作是通过该对象的引用（Reference）实现的。

Java中的引用类型有4种，分别为强引用、软引用、弱引用和虚引用。

## 强（最常见）

在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。

有强引用的对象一定为可达性状态，所以不会被垃圾回收机制回收。

因此，强引用是造成Java内存泄漏（Memory Link）的主要原因。

## 软（通过SoftReference类实现）

如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。

## 弱（通过WeakReference类实现）

如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。

## 虚（通过PhantomReference类实现）

虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。



# 7 分代收集算法和分区收集算法

## 分代收集

JVM根据对象存活周期的不同将内存划分为新生代、老年代和永久代，并根据各年代的特点分别采用不同的GC算法。

- 新生代（1/3堆，复制算法）
  - 主要存储短生命周期的对象。
  - 因此在垃圾回收的标记阶段会标记大量已死亡的对象及少量存活的对象，因此只需选用复制算法将少量存活的对象复制到内存的另一端并清理原区域的内存即可。
- 老年代（2/3堆，标记整理算法）
  - 主要存放长生命周期的对象和大对象。
  - 可回收的对象一般较少，因此JVM采用标记整理算法进行垃圾回收，直接释放死亡状态的对象所占用的内存空间即可。



## 分区收集

分区算法将整个堆空间划分为连续的大小不同的小区域，对每个小区域都单独进行内存使用和垃圾回收，这样做的好处是可以根据每个小区域内存的大小灵活使用和释放内存。





# 8 垃圾收集器











# 9 Java网络编程模型





# 10 JVM的类加载机制
