



## 上传csv/txt文件导入数据

控制层

```java
/**
 * 数据表导入数据
 * @param tableId 数据表ID
 * @param uploadFile 上传文件
 * @param fileType 文件类型
 * @param separator 分隔符
 * @param isFirstTitle 是否首行标题
 */
@PostMapping("/importQualityData")
public Result<Object> importQualityData(@ApiIgnore @RequestAttribute(value = Constants.SESSION_USER) User loginUser,
                                        @RequestParam("tableId") int tableId,
                                        @RequestParam("uploadFile") MultipartFile uploadFile,
                                        @RequestParam("fileType") int fileType,
                                        @RequestParam("separator") String separator,
                                        @RequestParam("startLine") int startLine,
                                        @RequestParam("isFirstTitle") boolean isFirstTitle
) throws SQLException, IOException {
    return customizationTableManageService.importQualityDataByType(loginUser, tableId, uploadFile, fileType,
            separator, startLine, isFirstTitle);
}
```



service 层

```java
@Transactional
@Override
public Result<Object> importQualityDataByType(User loginUser, int tableId, MultipartFile uploadFile, int fileType,
                                              String separator, int startLine, boolean isFirstTitle) {
    Result<Object> result = new Result<>();
    // separator 处理
    if (separator.equals("逗号")) {
        separator = ",";
    }
    if (separator.equals("分号")) {
        separator = ";";
    }
    if (separator.equals("Tab")) {
        separator = "\\t";
    }
    if (separator.equals("空格")) {
        separator = " ";
    }
    // 用户输入分隔符校验
    String delimiterStr = getDelimiter(uploadFile);
    if (!delimiterStr.equals(separator)){
        result.setCode(200);
        result.setMsg("所选分隔符与文件分隔符不匹配，请重新校验。");
        return result;
    }
    // 文件处理
    uploadFile = processUploadFile(uploadFile, separator, startLine, isFirstTitle, tableId);
    // 数据导入
    logger.info("processUploadFile finished");
    result = importData(loginUser, tableId, uploadFile, fileType, separator, startLine, isFirstTitle);

    return result;
}
```



文件处理 `processUploadFile`

```java
// 文件处理
private MultipartFile processUploadFile(MultipartFile file, String separator, int startLine, boolean isFirstTitle, int tableId) {
    // 获取文件名
    String fileName = file.getOriginalFilename();
    // 从MultipartFile获取输入流
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new InputStreamReader(file.getInputStream()));
    } catch (IOException e) {
        logger.error(e.getMessage(), e);
    }
    // 创建一个新的MultipartFile来保存修改后的内容
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream));
    String line = "";

    int count = 0;
    // 是否首行为标题
    if (isFirstTitle) {
        try {
            if (reader != null) {
                line = reader.readLine();
            }
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
        count = 1;
    }

    // 跳过行数
    for (int i = 0; i < startLine - count; i++) {
        try {
            if (reader != null) {
                reader.readLine();
            }
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
    }

    while (true) {
        try {
            if (!((line = reader.readLine()) != null)) break;
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
        // 将修改后的行写入输出流
        try {
            writer.write(line);
            writer.newLine();
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
    }
    try {
        writer.flush();
        writer.close();
    } catch (IOException e) {
        logger.error(e.getMessage(), e);
    }
    // 将修改后的内容转换为字节数组并创建新的MultipartFile对象
    byte[] bytes = outputStream.toByteArray();
    return new MultipartFile() {
        @Override
        public String getName() {
            return file.getName();
        }

        @Override
        public String getOriginalFilename() {
            return fileName;
        }

        @Override
        public String getContentType() {
            return file.getContentType();
        }

        @Override
        public boolean isEmpty() {
            return bytes.length == 0;
        }

        @Override
        public long getSize() {
            return bytes.length;
        }

        @Override
        public byte[] getBytes() throws IOException {
            return bytes;
        }

        @Override
        public InputStream getInputStream() throws IOException {
            return new ByteArrayInputStream(bytes);
        }

        @Override
        public void transferTo(File file) throws IOException, IllegalStateException {
            FileOutputStream fileOutputStream = new FileOutputStream(file);
            fileOutputStream.write(bytes);
            fileOutputStream.close();
        }
    };
}
```



导入数据 `importData`

```java
@Transactional
public Result<Object> importData(User loginUser, int tableId, MultipartFile uploadFile, int fileType,
                                 String separator, int startLine, boolean isFirstTitle) {
    Table table = customizationTableManageMapper.selectById(tableId);
    //1 creat tmp as/like a
    // 获取元数据
    String databaseName = table.getDatabaseName();
    String ddl = getTableDdl(table.getTableName(), table.getDatabaseName());
    logger.info("table ddl is: {}", ddl);

    int startIndex = ddl.indexOf("(");
    int endIndex = ddl.indexOf(")", startIndex);
    String fieldStr = ddl.substring(startIndex, endIndex + 1);
    logger.info("fieldStr is: {}", fieldStr);

    // 如果存在PARTITIONED BY，则提取PARTITIONED BY后面的括号内容
    int partitionedByIndex = ddl.indexOf("PARTITIONED BY");
    if (partitionedByIndex != -1) {
        int secondBracketStartIndex = ddl.indexOf("(", partitionedByIndex);
        int secondBracketEndIndex = ddl.indexOf(")", secondBracketStartIndex);
        String secondContent = ddl.substring(secondBracketStartIndex + 1, secondBracketEndIndex).trim();

        // 拼接两个内容
        fieldStr = fieldStr.substring(0, fieldStr.length() - 1) + ", " + secondContent + ")";
    }
    logger.info("fieldStr is: {}", fieldStr);


    StringBuilder sb = new StringBuilder();
    sb.append("CREATE TABLE ").append("`")
            .append(table.getTableName())
            .append("_tmp` ")
            .append(fieldStr)
            .append(" ROW FORMAT DELIMITED FIELDS TERMINATED BY '")
            .append(separator)
            .append("'")
            .append(" stored as textfile");
    logger.info("create tmp table with sql: {}", sb);

    //2 load
    //上传文件到HDFS
    String fullName = getFullName("/", uploadFile.getOriginalFilename());
    if (!upload(loginUser, fullName, uploadFile, FILE)) {
        logger.error("upload resource: {} file: {} failed.", RegexUtils.escapeNRT(uploadFile.getOriginalFilename()),
                RegexUtils.escapeNRT(uploadFile.getOriginalFilename()));
        throw new ServiceException(
                String.format("upload resource: %s file: %s failed.", uploadFile.getOriginalFilename(), uploadFile.getOriginalFilename()));
    }

    // 建表
    DatabaseUtils dataBase = new DatabaseUtils();
    Connection connection = null;
    Statement statement = null;

    String realDatabaseName = getDatabaseName(table);
    StringBuilder loadSqlSb = new StringBuilder();
    loadSqlSb.append("load data inpath '/dolphinscheduler/dolphinscheduler/resources/")
            .append(uploadFile.getOriginalFilename())
            .append("' into table ")
            .append(realDatabaseName)
            .append(".")
            .append(table.getTableName())
            .append("_tmp");
    //String loadSql = "load data inpath '/dolphinscheduler/dolphinscheduler/resources/" + uploadFile.getOriginalFilename() + "' into table " + realDatabaseName + "." + table.getTableName() + "_tmp";
    String insertSql = "insert into " + realDatabaseName + "." + table.getTableName() + " select * from " + table.getTableName() + "_tmp";
    String deleteSql = "drop table " + table.getTableName() + "_tmp";

    try {
        // 建立JDBC连接
        connection = getConnection(dataBase, databaseName);
        statement = connection.createStatement();
        // 执行建表
        statement.execute(getUseDatabaseSql(databaseName));
        logger.info("drop table with sql: {}", deleteSql);
        statement.execute(deleteSql);
        logger.info("create table with sql: {}", sb);
        statement.execute(sb.toString());

        statement.execute(loadSqlSb.toString());
        //3 insert A select tmp
        statement.execute(insertSql);
        //4 drop
        statement.execute(deleteSql);

    } catch (SQLException e) {
        logger.error(e.getMessage(), e);
        throw new RuntimeException("sql 错误！");
    } finally {
        DatabaseUtils.closeResources(connection, statement, null);
    }

    Result<Object> result = new Result<>();
    result.setCode(Status.SUCCESS.getCode());
    result.setMsg(Status.SUCCESS.getMsg());
    return result;
}
```





## OOM

```shell
JAVA_OPTS=${JAVA_OPTS:-"-server -Duser.timezone=${SPRING_JACKSON_TIME_ZONE} -Dspring.profiles.active=dev -Xms2g -Xmx2g -Xmn1g -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5004 -XX:+PrintGCDetails -Xloggc:gc.log -XX:+HeapDumpOnOutOfMemoryError -Dsun.security.krb5.debug=true -XX:HeapDumpPath=dump.hprof"}
```















