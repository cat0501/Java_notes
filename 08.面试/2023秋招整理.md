# 58 同城

## 01

公司正在进行优秀项目组评比的初选工作，评委会已经根据 K个项目组提交的材料完成打分，各项目组分数为S1,S2,S3...Sk。

评委会希望设定一个初级晋级分数线x，使得所有得分大于x的项目组晋级，其他淘汰，同时，希望晋级和淘汰的项目组数量都在 [m,n] 区

间。显然 x 可能不存在，也可能存在多个 x。若不存任则输出 -1，若存在多个，则输出满足条件的所有分数线的最小值。





## 02

给定一个从 0 开始的数组 nums 和一个非负整数 k。在一次操作中，你可以做以下操作：

选择一个之前未选择过的下标 i，范围为 [0,nums.length - 1]。

将 nums[i] 替换为范围 [nums[i]-k, nums[i]+k]内的任意整数（包含两端）。

在应用任意次数的操作后，返回数组nums的最大可能分数。数组分数是数组中最多的重复元素个数。

注意，你只能对每个下标应用一次操作。

```
输入
[4,6,1,2],2
输出
3
```





## 03

例如，一个序列可抽象为 “AABCCD”，识别横式为“CCD”，由于"CCD”是序“AABCCD” 的子序列，则表示模式匹配，即可对黑产账号进行处置。

现在，给你一些序列和识别模式，请你找出该序列有多少个这样的子序列。如果子序列不存在则返回0。

```sh
输入
"ABC","A"
输出
1
```



## 面试

算法题：给一个字符串判断里面的三种括号是否正确匹配



### 01 门头沟计算机0922（40分钟）

自我介绍、成绩排名

实习内容

1. hashmap数据结构，为什么要用红黑树

```
用于存储键值对
当我们插入或查询一个键值对时，HashMap 首先通过哈希函数计算出键的哈希值，然后根据哈希值确定该键值对在数组中的位置。
通常情况下，我们会使用数组的索引来直接访问对应位置的元素。然而，在某些情况下，多个键的哈希值可能会冲突，导致它们被映射到数组的同一位置上。这种情况下，我们需要解决哈希冲突。
使用链表来连接相同哈希值的键值对。然而，如果链表过长，会导致查询效率下降，因为需要遍历整个链表才能找到目标键值对。为了解决这个问题，当链表长度超过一定阈值时，HashMap 会将链表转换为红黑树。
红黑树相比链表，在插入、删除和查找操作上具有更高的效率。因为红黑树是自平衡的二叉搜索树，它的插入、删除和查找操作的时间复杂度都是O(log n)，而链表的时间复杂度是O(n)。所以当链表较长时，将其转换为红黑树可以提高 HashMap 的性能。

总而言之，红黑树在 HashMap 中被用作链表的替代结构，用于解决键哈希冲突时的性能问题，提高了查找效率。
```



2. concurrenthashmap数据结构

```
ConcurrentHashMap 是 Java 中的一个线程安全的哈希表实现。它是 HashMap 的线程安全版本，主要用于在多线程环境下进行并发操作。

数据结构基本上和 HashMap 类似，都是通过一个数组来存储键值对。不过，ConcurrentHashMap 在内部使用了一种叫做分段锁（Segment）的机制来实现线程安全。

ConcurrentHashMap 将整个数据结构分成了多个段（Segment），每个段相当于一个小的哈希表。在每个段内部，通过加锁的方式来保证线程安全，不同的段之间可以并发地进行操作，从而提高了并发性能。

并提供了一定的一致性和原子性保证。
```





3. mysql的索引介绍一下

```
索引是数据库中用于提高查询性能的重要机制之一。是一种特殊的数据结构，它可以帮助数据库系统快速定位和访问表中的数据。

MySQL 支持多种类型的索引：
B-Tree 索引：B-Tree（平衡树）是一种常用的索引结构。它可以以有序的方式存储索引数据，并且能够快速进行数据的查找、插入和删除操作。在 MySQL 中，默认情况下，主键（Primary Key）和唯一索引（Unique Index）都是使用 B-Tree 索引来实现的。

哈希索引：哈希索引是将关键字通过哈希函数计算，然后存储在哈希表中。通过哈希索引可以快速获取到具有特定哈希值的记录。但是哈希索引只适用于等值查询，对于范围查询的效果不好。在 MySQL 中，只有 MEMORY 引擎支持哈希索引。

全文索引：全文索引是一种用于全文搜索的索引类型。它可以在文本字段中快速匹配关键词，提供高效的文本搜索功能。在 MySQL 中，只有基于 MyISAM 引擎的表支持全文索引，而 InnoDB 引擎可以使用全文搜索插件来实现类似的功能。

创建索引时需要权衡索引的性能提升和对数据操作的影响。索引可以加快数据的检索速度，但在插入、更新和删除数据时需要额外的时间和空间开销。
```



4. 有个电话系统 如何判断打来的电话不是空号(我说的数据格式校验和布隆过滤器，面试官说还有没有其他的我想不出来了)

```
数据格式校验\布隆过滤器

号码归属地查询：通过将打来的电话号码进行号码归属地查询，可以判断该电话号码是否属于有效的号码段。这种方法需要使用第三方的号码归属地数据库或API来进行查询。

拨打验证：通过真实拨打打来的电话号码，观察是否能够成功连接对方。

查询运营商返回结果：可以通过与运营商系统进行交互，查询该电话号码的状态。运营商会提供一个接口或服务来查询电话号码的是否有效、状态是否正常等信息。
```



```
是的，布隆过滤器可以用于判断打来的电话号码是否为空号。

布隆过滤器是一种快速且高效的概率型数据结构，用于判断一个元素是否存在于一个集合中。它通过使用一系列的哈希函数和一个位数组来实现。具体操作如下：

1. 初始化：需要确定布隆过滤器的大小和哈希函数的个数。同时，需要创建一个位数组，并将所有的位都初始化为0。

2. 添加元素：当有一个电话号码打来时，将该电话号码通过多个哈希函数得到多个哈希值，然后将位数组中对应位置上的位设置为1。

3. 查询元素：当有电话号码打来时，也通过多个哈希函数得到多个哈希值，然后检查位数组中对应位置上的位是否都为1。若存在任何一个位置上的位为0，则可以判断该电话号码不在布隆过滤器所代表的集合中，即该电话号码可能是空号。

布隆过滤器的优点是快速且占用空间相对较小，可以处理大规模数据集合的查询，并且查询速度非常快。但布隆过滤器也存在一定的缺点，主要是存在一定的误判率（即某些不在集合中的元素也可能被误认为在集合中）。

使用布隆过滤器进行电话号码空号判断时，可以逐步添加已验证的电话号码，并在每次来电时查询布隆过滤器判断号码是否为已添加的号码。这样可以快速地判断号码是否是空号，避免进行不必要的查询请求。

需要注意的是，布隆过滤器无法提供确定性的结果，只能提供概率性的结果。因此，在使用布隆过滤器进行电话号码空号判断时，可能会存在一定的误判率。
```



5. sql优化是怎么进行的？

```
SQL 优化是对 SQL 查询语句进行调整和优化，以提高数据库查询性能的过程。以下是一些常见的 SQL 优化技巧：

索引优化：通过合理创建和使用索引，可以大大提高数据库查询的性能。使用索引可以减少数据的扫描和比较，加快数据的检索速度。需要根据具体查询需求和数据访问模式来选择合适的索引类型、创建正确的索引，以及避免过多的索引和索引失效等问题。

查询语句优化：优化查询语句本身是提高查询性能的关键。可以通过优化查询的写法，减少不必要的计算和扫描操作，合理使用关键词、条件和筛选顺序等等。例如，使用合适的 JOIN 语句代替子查询、使用 UNION ALL 代替 UNION、避免使用 SELECT * 等都可以提高查询效率。

避免全表扫描：尽量避免对整个表进行全表扫描，因为全表扫描需要消耗大量的时间和资源。可以通过合理的索引、使用 WHERE 子句和 LIMIT 关键词等方式来限制查询范围，减少扫描数据量。

数据库分区：对于大型数据库或者数据量很大的表，可以考虑对数据进行分区。通过分区可以将数据分散存储在不同的物理文件中，减少查询范围，提高查询性能。

缓存查询结果：对于一些频繁被查询的数据，可以考虑缓存查询结果。通过缓存可以避免重复查询，降低数据库的负载，提高查询的响应速度。

定期优化和维护：定期进行数据库的优化和维护是保持数据库性能的重要手段。可以通过数据库统计信息的收集、索引重建和碎片整理等操作来提高数据库的性能。
```



6. redis数据结构用过哪些 怎么用的？

```
Redis 是一种基于内存的高性能键值数据库，支持多种数据结构。下面介绍一些常用的 Redis 数据结构及其使用方式：

字符串（String）：用于存储字符串类型的值。可以用于缓存、计数器等场景。使用 SET 命令设置值，GET 命令获取值。

哈希（Hash）：用于存储键值对的无序散列表，每个键都对应一组字段和值。适用于存储对象属性。使用 HSET 命令设置键值对，HGET 命令获取对应值。

列表（List）：按照插入顺序存储的字符串元素集合。适用于消息队列、简单日志等场景。使用 LPUSH 和 RPUSH 命令在左或右端插入元素，使用 LPOP 和 RPOP 命令从左或右端删除元素。

集合（Set）：无序且唯一的字符串集合。适用于标签、好友关系等场景。使用 SADD 命令添加元素，使用 SMEMBERS 命令获取所有元素。

有序集合（Sorted Set）：类似集合，每个元素关联一个分数，按照分数排序。适用于排行榜、时间线等场景。使用 ZADD 命令添加带有分数的元素，使用 ZRANGE 命令按照分数范围获取元素。

Bitmap：位图存储。适用于统计、权限控制等场景。使用 SETBIT 命令设置位，使用 BITCOUNT 命令统计位的个数。

HyperLogLog：基于概率算法的数据结构，用于统计元素的基数（不重复元素的个数）。使用 PFADD 命令添加元素，PFMERGE 命令合并统计结果。

除了上述的数据结构，Redis 还提供了其他一些特殊用途的数据结构，如地理位置（Geospatial）等，可以根据具体的业务需求选择合适的数据结构来存储和操作数据。
```



7. redis哨兵介绍一下 哨兵根据什么来选择新的主节点

```
Redis 哨兵（Sentinel）是 Redis 的一种高可用解决方案，用于监控和管理 Redis 主从复制架构中的节点，并在主节点故障时自动选择新的主节点。它具有以下主要功能：

1. 监控：哨兵通过周期性发送心跳检测命令，实时监控 Redis 主、从节点的健康状态。如果发现主节点故障或从节点数量低于指定数量，哨兵将触发故障转移操作。
2. 自动故障转移：当哨兵检测到主节点失效时，它会从众多的从节点中选择一个合适的节点作为新的主节点。选举的条件包括从节点复制偏移量、优先级等。
3. 配置提供和维护：哨兵会定期检查 Redis 配置，确保节点的配置文件与期望配置一致。如果配置不一致，哨兵会自动将节点配置为正确的值。
4. 通知和提醒：哨兵会通过发布和订阅机制通知客户端应用程序主节点变更和故障转移等重要事件。这允许应用程序能够实时感知节点状态的变化。

哨兵选择新的主节点时，主要根据以下因素进行判断：
1. 优先级：哨兵将根据 Redis 节点的配置文件中设置的优先级来选择主节点。优先级较高的节点更有可能被选举为新的主节点。
2. 从节点的复制偏移量：哨兵会选择复制偏移量最大的从节点作为新的主节点，以确保数据的一致性。
3. 选举时间：如果多个从节点具有相同的优先级和复制偏移量，哨兵会选择最早向哨兵报告主节点故障的从节点作为新的主节点。

需要注意的是，哨兵的选举过程是自动进行的，并且是基于特定规则和算法来进行判断的。哨兵会不断监控节点的健康状态并进行故障转移，以确保 Redis 集群的高可用性和可靠性。
```



8. 一道很简单的sql题

9. 一道很简单的链表算法题（合并有序链表并反转）

反问：表现怎样 面试结果多会出(看二面面试官 会有hr联系)

### 02 中国科学院大学计算机0921

```
1.谈谈对java多线程的理解，可以结合具体的项目，如何处理不同线程返回超时、错误等问题
2.谈谈JVM的内存模型、类加载机制和垃圾回收机制，想到什么说什么。
3.谈谈对SpringBoot的理解，以及对微服务框架是怎么理解的。
4.你自己常用的Redis类型是什么，项目中有用到吗，举个例子
5.谈谈Redis雪崩和穿透的区别
6.谈谈对MySQL的索引的理解
7.知道Redis的持久化吗？有哪些方式？各有什么优缺点。
8.场景题：小内存处理大数据

按照简历问的，写的专业技能的内容，一项一项问的。项目没问。
```

1. 谈谈对java多线程的理解，可以结合具体的项目，如何处理不同线程返回超时、错误等问题

```
多线程

理解：各个线程之间可以并发执行任务，从而实现程序的并发处理能力。多线程可以提高程序的性能和响应速度，但也带来了一些挑战，比如线程安全、并发控制等问题。


处理不同线程返回超时、错误等问题的方法可以根据具体项目需求和场景进行选择，以下是一些常用的方法：：
使用 Future 和 Callable：通过使用 Java 并发包中的 Future 和 Callable 可以实现对线程的监控与控制。Callable 接口可以用来封装要在新线程中执行的任务，Future 接口则可以获取任务的执行结果或取消任务。可以设置超时时间，当任务执行超时，可以通过调用 Future 的 cancel 方法取消任务。

使用 CompletableFuture：Java 8 引入的 CompletableFuture 类可以更方便地处理多线程任务。它支持链式操作，可以通过 thenApply、thenAccept、thenCombine 等方法来处理任务的完成结果、异常情况和超时等操作。

使用定时任务和超时处理：可以使用 Java 定时任务的机制来设置超时时间，在任务超时后进行相应的处理。可以使用 Timer 类或者 ScheduledExecutorService 接口来实现。

使用线程池：使用线程池可以更好地管理和复用线程资源，同时可以限制并发数，控制线程的执行和资源消耗。可以使用 ThreadPoolExecutor 类来创建和管理线程池，设置超时时间和错误处理等。

通过中断机制：线程间可以通过中断标志来进行通信和中断处理。可以通过调用线程的 interrupt 方法来设置中断标志，然后在线程内部检查中断标志，及时响应中断信号并进行相应的处理。
```

2. 谈谈JVM的内存模型、类加载机制和垃圾回收机制，想到什么说什么。

```
当谈到 JVM 的内存模型、类加载机制和垃圾回收机制时，以下是一些相关的概念和要点：

1. 内存模型：JVM 的内存模型定义了程序运行时所需的内存布局和访问规则。主要包括栈（Stack）、堆（Heap）、方法区（Method Area/CMS）、程序计数器（Program Counter）和本地方法栈（Native Method Stack）等。栈用于存储方法调用和局部变量，堆用于存储对象实例，方法区用于存储类信息和常量池，程序计数器用于记录当前线程的执行位置，本地方法栈用于支持 native 方法的执行。

2. 类加载机制：Java 类加载机制负责将编译后的字节码文件加载到 JVM 中并进行解析和初始化。类加载器（ClassLoader）负责加载类文件，它分为启动类加载器、扩展类加载器和应用程序类加载器等。类加载过程包括加载、链接（验证、准备、解析）和初始化三个阶段。加载阶段将字节码加载到内存，链接阶段对字节码进行验证、准备内存和解析符号引用，初始化阶段执行静态变量赋值和静态代码块。

3. 垃圾回收机制：JVM 的垃圾回收机制负责自动回收不再使用的对象所占用的内存空间，以便为新的对象提供内存。垃圾回收通过检测对象的可达性来判断对象是否需要被回收。主要的垃圾回收算法包括标记-清除（Mark-Sweep）、复制（Copying）、标记-整理（Mark-Compact）等。常见的垃圾回收器包括串行收集器（Serial）、并行收集器（Parallel）、CMS 收集器（Concurrent Mark Sweep）和 G1 收集器（Garbage First）等。其中，G1 收集器是一种面向大内存、高并发应用场景的垃圾回收器。

除了以上提到的概念，JVM 的内存模型涉及到堆内存和栈内存的分配、对象的引用和引用计数等概念。类加载机制还包括类加载器的双亲委派模型和破坏双亲委派模型的方式。垃圾回收机制还涉及到垃圾回收算法的选择、GC 日志分析和调优等方面。

总之，JVM 的内存模型、类加载机制和垃圾回收机制是 Java 程序运行的基础，并且对程序性能和稳定性有着重要影响。深入理解和掌握这些概念将有助于开发人员编写高效、可靠的 Java 应用程序。
```

3. 谈谈对SpringBoot的理解，以及对微服务框架是怎么理解的。

```
Spring Boot 是一个用于简化和加速构建基于 Spring 框架的应用程序的开发框架。它提供了诸多开箱即用的特性和约定。
对于 Spring Boot 的理解，可以总结为以下几个关键点：

1. 简化配置：Spring Boot 提供了丰富的自动配置，减少了繁琐的配置工作。通过约定大于配置的原则，开发者可以少量甚至无需编写配置，而是通过约定好的命名、注解和默认值来完成配置。

2. 内嵌容器：Spring Boot 可以将应用程序打包为包含内嵌容器（如 Tomcat、Jetty 或 Undertow）的可执行 JAR 文件，使得应用程序可以独立运行，而无需依赖外部容器的安装和配置。

3. 自动化依赖管理：Spring Boot 提供了强大的依赖管理能力。通过 Starter 依赖，开发者可以方便地引入所需的模块和第三方库，而无需手动解决依赖冲突和版本兼容性问题。

4. 微服务支持：Spring Boot 是构建微服务架构的理想选择。它提供了对微服务相关技术（如服务注册与发现、负载均衡、断路器、配置中心等）的支持，并与 Spring Cloud 生态系统无缝集成，使得开发者可以轻松构建和管理分布式、可伸缩、高可用的微服务架构。

对于微服务框架的理解，它是一种将复杂的单体应用拆分为一系列小型、独立的服务的架构设计风格。每个服务都有自己的独立部署、扩展和维护。微服务框架通过服务间的通信和解耦，并采用适当的技术和工具来管理服务的发现、负载均衡、熔断、配置等问题，从而实现高可用性、弹性和可伸缩性。

微服务框架提供了一些核心特性，如服务注册与发现、服务网关、服务间通信、负载均衡、熔断机制等。Spring Cloud 是一个基于 Spring Boot 的开源微服务框架，它为开发者提供了一整套的微服务工具和组件，如 Eureka、Zuul、Feign、Ribbon、Hystrix 等，简化了微服务架构的开发和部署。

通过使用 Spring Boot 和 Spring Cloud，开发者可以更加便捷地构建和管理微服务架构，实现更高效、可扩展的应用程序开发。
```

4. 见前面的

5. 谈谈Redis雪崩和穿透的区别

```
```







### 03 中海洋计算机0922

自我介绍

多个字符串最长公共前缀

简单问了点项目，不太感兴趣就没深挖

```
1.tcp，udp，ip
2.两台设备通信怎么知道穿的数据是给哪一个应用程序的
3.数据库索引
4.快排的原理
5.进程线程的区别，通信方式
6.互斥锁和读写锁
```

反问





### 04 石家庄铁道大学计算机0922（不到30分钟）、哈工大

更多是Java基础

```
双亲委派机制
类加载流程
Java内存模型
好多jvm相关问题忘了
线程怎么启动，start方法调用两次发生什么？直接调用run方法？
sleep和awit区别
cas是什么，会有什么问题
线程池参数，阻塞队列选择无界还是有界，会有什么问题
计算机网络tcp和http区别
MySQL事务，保证原子性的原理
MySQL索引结构，b树和B+树区别
执行一条查询sql（for update），是否会用到锁，用到什么锁
Redis主从原理是什么
Redis缓存淘汰策略
熟悉的数据结构
说快排思路，原理（递归+分治）
LRU算法了解吗，有什么实现思路
```



### 05 蚌埠 电子信息类

```
1.自我介绍
2.挖项目（吟唱中被直接打断施法）
3.什么情况下加索引
4.你知道的分库分表的工具（不让讲原理，直接说工具，原谅我真的没遇到过这种场景）
5.单表怎么优化，有什么方法
6.你知道的锁都有哪些，Java的，操作系统的等等，详细说说他们之间的关系以及使用场景
7.tcp四次挥手的流程以及状态流转
8.创建线程的方法都有哪些，内置的线程池都是什么，展开说下。
9.知道什么是守护进程吗，讲一下什么是守护进程
```





































# 猿辅导

## 01



—位特别有责任心的老师，为了给学生带来高质量的课堂，翻阅了非常多的书籍，最后终于挑出了最有价值的几类书，
并写了一个类目录，每个类用一个小写英文字母代表，比如m代表math.
老师振臂高呼太棒啦，却一不小心把所有书籍散落在了地上，你能帮帮老师统计出每个类下有多少书籍吗？
举例，老师统计的目录为[a,b,m]。散落在地上的书籍为a,a,m,m,b,d,d,x,x。则你应该统计的结果：a 2,b 1,m 2。

[a,m,b]
a,a,m,m,b,d,d,x,x

## 02

教室中间有一条走廊，出口如图，在走廊两旁有几排座位，同学们随意坐在不同的座位上，假设每个单位时间 学生们可以移动距离为1，目同一时间同一个位置只能有一个同学。所有同学的下课出教室路径都是从座位先移动到走廊，然后走到门口即可。
假设走廊是y轴，出口是(0,0)。
输入描述：
输入n代表学生数。后面n行输入，每行2个数字，表示学生坐标x y
输出描述：
输出最短时间t
给我一个Java ACM解法



如果输入为
3
3 4
-3 4
2 3

正确输出为8





## 03

有一个树形的棋盘，棋盘上有n个结点，由n-1条边连接起来，每个结点摆放有黑色或者白色的棋子。
玩家可以选择棋盘上任意两个不同的结点x,y，如果从x出发到达y的最短路径上任意两个相邻的结点都有不同的颜色，
那么玩家就能够将路径上的棋子全部消除掉（包括x，y)。消除掉的节点越多，玩家获得的奖品越丰厚。
为了能消除更多的棋子，允许玩家最多能改变k个棋子的颜色。现在玩家只有一次消除棋子的机会，请问最多能消除掉多少个棋子。

输入描述：
第一行输入两个整数n，k
第二行输入n个整数，其中第i个整数代表编号为i的结点上棋子的颜色（0代表白色 1代表黑色），结点编号从1到n
接下来n-1行，每行2个整数x,y表示结点x,y相连（无向边）,其中1<=x,y<=n

输出描述：
输出一个整数代表最多能消除的棋子数
给我一个Java ACM解法

3 1
0 0 0
1 2
3 

3

4 0
1 1 0 0
2 3
2 4
1 2

3



# 信也 0918

60分钟、20单选 5多选 1问答 2编程

## T1

https://blog.csdn.net/m0_58761900/article/details/126947774





## T2

有一个神奇的背包，总的承重是M，用这个背包可以装下一些物品，这些物品的总重量必须是M。Bob现在有n个想要得到的物品，每个物品的重量分别是a1，a2．．．．．．an，Bob可以从这些物品中选择一些，如果选出的物品的总重量是M，那么利用这个神奇的背包，Bob就可以得到这些物品。现在的问题是，Bob有多少种不同的选择物品的方式。


输入描述：
第一行M表示背包总的承重
第二行正整数n表示不同的物品的数量
接下来n行，每行有一个1到M之间的整数，分别给出a1，a2．．．．．．an的值

ACM java给我一个解法

```sh
40
3
20
20
20
```





```java
import java.util.Scanner;

public class A0918_02 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int M = scanner.nextInt();
        int n = scanner.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }

        int[][] dp = new int[n + 1][M + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= M; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= a[i]) {
                    dp[i][j] += dp[i - 1][j - a[i]];
                }
            }
        }

        System.out.println(dp[n][M]);
    }
}
```





# 掌阅 0918

1.5h、20选择30分、2简答20分、3编程40分

## 简答20分

什么是数据库事务，简述事务ACID特性的含义

什么是死锁，如何避免和解决死锁问题

## T1 长度最小的子数组

leetcode 原题

## T2 背包问题

小阅（掌阅吉祥物）在掌阅应用上有一些阅饼，他可以使用这些阅饼兑换一些书籍。
他想兑换很多，且每本书只需要兑换一次，但由于阅饼有限不能兑换到所有书，因此他将想兑换的每本书设置了1个价值，代表读完该书带来的收益值。
他想请你帮忙计算一下，所总换的书籍价值之和最大是多少

输入描述：
第一行输入s和n，代表有s个阅饼和n本书，s的范围是[1，10000］，n的范围是［1，500］。
接下来n行的每一行有两个数c，v，代表该书需要的阅饼数和价值，c和v的范围是［1，10000］

输出描述：输出兑换书籍的最大值

输入样例：
10 2
7 12 
6 14

输出样例：
14

## T3 智能机器人

小阅（掌阅吉祥物）正在进行一项有趣的测试，以评估机器人在解决迷宫问题上的智能程度。
因此他将机器人放在一个n＊m的迷宫中，看机器人最少需要走多少步到达目的地。

输入描述：
输入包含两行，第一行代表n和m，n和m的范围是［2，2000］，接下来n行，每行包含m个字符，代表迷宫的方格，
包含四种字符：'s'代表机器人出发点，'e'代表机器人终点，'.'代表可通过，'#'代表禁止通过。

输出福述：
输出最短需要时间，如果不能到达则输出—1。

输入示例如下
3 3
.s.
#..
e..

ACM 模式Java给我个解法









# 顺丰 0920



## T1



小红拿到了一个字符串s。她可以进行任意次以下操作：
选择字符串中的一个字母ch1和任意一个字母ch2（ch2可以不在字符串中出现），将字符串s中的所有
ch1变成ch2。
小红想知道，自己能否通过一些操作将字符串s变成t?

输入描述
第一行输入一个正整数q，代表查询次数。
然后每2行代表一次查询：第一行输入一个字符串s。第二行输入一个字符串t。1≤q≤10
保证s和t的长度相同，且均由小写字母组成。长度不超过10000

示例输入
3
ab
ba
abc
aaa
aaaa
abcd

示例输出
Yes
Yes
No

ACM 模式Java给我个解法





## T2

野猪骑士最近在一条路上锻炼，整条路可以被分作n块地块，每个地块有自己的高度hi，
i属于集合｛1，2，3，．．．，n｝．野猪骑士在地块i时，会跳向下标比i大且高度比hi严格大的地块的集合
中高度最小的地块。

野猪骑士希望知道自己在每个地块上的下一跳的目的地的高度，如果下一跳不存在的话，则记为—1。
但这对野猪骑士来说太难了，他希望你来帮助他。

更形式化地说，给定一个数列h，求一个数列d，其中如果｛hj|j＞i＆hj＞hi｝≠Ø，则
di：＝min｛hj｜j＞i＆hj＞hi｝，否则di：＝-1 （其中：＝是赋值符号）。

输入描述:
第一行包括一个正整数n，第二行包含n个正整数h1,h2,....,hn.

输出描述：
一行，包括n个正整数d1,d2,...dn

ACM 模式Java给我个解法

输入示例：
4
4 1 2 3

输出：
-1 2 3 -1







# 携程 0921



游游拿到了一个排列a。她希望你构造一个长度相等的排列b，满足ai≠bi且b的字典序尽可能小。你能帮帮她吗？
所谓排列，即长度为n的数组，其中1到n每个正整数都恰好出现了1次。



输入描述
第一行输入一个正整数n，代表排列a的长度。
第二行输入n个正整数ai，代表游游拿到的排列。

输出描述
n个正整数bi，代表构造的排列。


示例输入
3
1 2 3
示例输出
2 3 1

ACM 模式Java给我个解法





游游拿到了一个n行m列的字母矩阵，矩阵中所有字符都是小写字母。
游游想知道，有多少个子矩阵满足，每个字母最多出现一次？

输入描述
第一行输入两个正整数n和m，代表矩阵的大小。

输出描述
每种字母只出现一次的子矩阵的数量

输入示例
2 3
aad
abc
输出示例
13

ACM 模式Java给我个解法







游游拿到了一个正整数，她准备恰好修改其中k位，使得该正整数变成75的倍数。
你能帮游游求出有多少种修改方案吗？
修改后，仍是正整数，且不允许存在前导零，答案请对10的9次方再加7取模。

输入描述
第一行输入一个正整数n。

输出描述
修改的方案数，对10的9次方再加7取模。

示例输入
355
2
对应输出
9

ACM 模式Java给我个解法





# 美团 0923

小美有一个长度为n的数组a。
如果一个序列b满足对于任意的i≥2，都有bi＝b(i-2)，则这是一个好序列。
小美想知道数组a的子序列中，最长的好序列的长度是多少。

子序列是指在一个序列中去掉一些元素而不改变剩余元素的相对位置所得到的序列。也就是说，如果
一个序列S可以通过去掉其中的一些元素得到另一个序列T，则称T是S的子序列。

输入描述
第一行一个整数n，表示数组a的长度。第二行n个整数，表示数组a的元素。

输出描述 输出一个整数
表示最长的好序列的长度

ACM 模式Java给我个解法


4
1 2 1 2




数列生成规则是：首先是1，然后是2到1，然后是 3 到 1，…………以此类推，每次从k到 1 加入数列然后k自增 1。
如：1,2,1,3,2,1,4,3,2,1,5,4,3,2,1,..
那么数列的前n项和等于多少。你能帮帮她吗？

输入描述
输入一个正整数n

输出描述
一个整数，代表前n项的和。
比如输入4，那么就是数列的前四项，应该输出7，即1,2,1,3的和
由于答案过大，请对10的9次方 + 7取模

ACM 模式Java给我个解法






小美拿到了一个钟表，上面显示的时间格式是＂xx：xx＂，其中，：前面表示小时，后面表示分钟。
时间为24小时制，从00：00到23：59。

现在给定一个初始的时间，以及给定小美对钟表修改的时间量，求最终钟表显示的时间。
小美每次的修改用＂＋x＂或者＂—x＂表示，分别代表时间往后调x分钟、时间往前调x分钟。

输入描述：
第一行输入一个长度为5的字符串，表示初始时间。第二行输入一个正整数n，代表小美的操作次数。
接下来的n行，每行首先输入一个字符ch，代表调整的策略，然后输入一个空格和正整数x，代表调整的分钟数。

输出描述：
一个长度为5的字符串，代表最终时间

ACM 模式Java给我个解法


输入
00.00
2

2

5
输出
00:57






小美这学期一共有n场考试，成绩分别为a1，a2，···，an。
小美想知道从第二场考试到最后一场考试，有多少场考试的成绩低于之前所有考试的最低分，或者高于之前所有考试的最高分。

输入描述:
第一行一个整数n，表示考试场数。
一行n个整数a1，a2，···，an，表示每场考试的成绩。

输出描述：
一行一个整数，表示答案。

ACM 模式Java给我个解法



# 网易

小红有一个长度为n的数组，数组下标为0到n—1，每次可以交换下标为i和（i＋2）％n的数，
请问小红能否通过有限次交换使得数组变成一个单调不减的数组。

输入描述
第一行一个整数t，表示数据组数。
接下来t组数据，每组数据第一行一个整数n，表示数组长度。
每组数据第二行n个整数ai，表示数组的值。1≤t≤10

输出描述 
对于每组数据，如果可以通过有限次交换使得数组变成一个单调不减的数组输出YES，否则输出NO

ACM java给我个解法


2
4
1 4 3 2
4
4 3 2 1
NO








小红拿到了一棵树，她有q次询问，每次会选出一个点集，小红希望你使用尽可能少的简单路径覆盖点
集中的所有节点。你能帮帮她吗？

输入描述
第一行输入两个正整数n和q，代表树的节点数量和小红的询问次数。
接下来的n—1行，每行输入两个正整数u和v，代表节点u和节点v有一条边连接。
接下来的2＊q行，每两行代表一次询问。
每次询问的第一行为一个正整数m，代表点集的大小。第二行为m个正整数ai，代表点集中的节点编号。

输出描述
输出q行，每行输出一个正整数，代表每次询问覆盖点集中所有点的最少路径数量。

示例1
输入
4 2
1 2
1 3
1 4
3
1 2 3
3
2 3 4

输出
1
2 


ACM java给我个解法







1．【算法】编程题：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为Ai（i为n个物品的顺序下标，每个物品只能选择一次且物品大小均为正整数）











# 小米







# 360

## T1

某公司有n名员工，第i名员工具有的能力可以用一个正整数ai描述，称为员工的能力值。
现在，公司有一个项目需要交给恰好［n／2]名员工负责，为了保证项目能顺利进行，要求负责该项目的所有员工能力值之和大于等于x。
公司希望你可以帮忙求出，有多少种不同的派遣员工来负责这个项目的方案。
上文中，［x]表示大于等于x的最小整数，例如［4］＝4，［4.2]＝5，认为两个方案不同，当且仅当存在一名员工在一种方案中负责该项目，而在另一种方案中不负责。

输入描述
输入包含多组数据，输入第一行包含一个整数T，表示数据组数。
接下来2T行，每两行描述了一组数据。
每组数据第一行包含两个正整数n（1≤n≤16）和x分别表示公司的员工总数和项目对负责员工能力值之和的要求。
每组数据第二行包含n个整数，第i个整数表示第i名员工的能力值ai。

输出描述
输出包含T行，对于每组数据输出一行一个整数，表示可行的派遣方案数。

ACM 模式Java给我个解法







## T2

https://blog.csdn.net/qq_38632594/article/details/126822747





```
6
16=1+2*3
7*8*9=54
1+1=1+22
4*6=22+2
15+7=1+2
11+1=1+5
```













# 面试整理

1. 你怎么知道产生了慢查询的情况？索引应该怎么加？

- 慢查询
  - 分析和优化查询语句。避免不必要的连接和子查询。
  - 通过慢查询日志定位。（默认不开启）
  - 用 Explain 查看 SQL 的执行计划（模拟优化器执行查询语句，帮助我们理解查询是如何执行的）
- 加索引
  - 考虑选择合适的列作为索引：选择经常用于筛选、连接或排序的列作为索引。唯一性较高的列（如主键）通常也适合用作索引。
  - 考虑联合索引：如果多个列经常一起出现在查询条件中，可以考虑创建联合索引，以提高查询性能
  - 避免过多的索引：权衡选择合适的索引数量。



2. 既然都是基于内存的，那么es和redis有什么区别

- es以JSON文档形式存储和索引数据。redis以键值对的形式存储数据，并支持丰富的数据类型，如字符串、哈希表、有序集合等。
- 强大的全文搜索和复杂的数据分析功能，ES是一个不错的选择。快速的读写操作和缓存功能，Redis更适合。



3. 数据库本身也有自己的缓存 为什么还要用radis来缓存

- 数据库本身通常具有内置的缓存机制，如MySQL的查询缓存或Oracle的共享池。这些缓存机制可以在一定程度上提高数据库查询性能，减少对磁盘的访问。
- 使用Redis作为独立的缓存层仍然有以下一些优势
  - 更高的性能：Redis是基于内存的键值存储系统，相对于传统磁盘数据库，它具有更快的读写速度和更低的延迟。特别适用于缓存热门数据和频繁查询的数据。
  - 解耦数据库压力：将一部分读请求从数据库转移到Redis中处理



5. 微服务和单体服务有什么区别为什么要把服务拆开如果是为了承载更大的访问量 为什么不考虑做成集群

- 区别
  - 两种不同的架构风格，它们在设计原则和实现方式上存在一些区别。
- 为什么要将服务拆分为微服务呢？
  - 独立开发和部署
  - 可扩展：将扩展的粒度缩小到每个服务
  - 高可用和容错性：实现部分故障隔离和容错。如果一个服务发生故障，其他服务仍然可以正常工作，从而提高整体系统的可用性。
  - 避免JAR冲突
- 为什么不仅仅考虑将单体服务部署为集群，而选择微服务架构
  - 部署和扩展的灵活性：每个服务都可以独立进行部署和扩展。
  - 解耦和隔离
  - 技术栈和工具的选择：每个微服务可以选择适合自身的技术栈和工具。



6. 微服务下数据怎么共享 集群中修改数据怎么保证一致性

- 分布式数据库、一致性协议和分布式锁、各自维护私有数据



7. 用户在请求数据的时候 请求的是哪里的数据是服务器上的吗 怎么保证本地缓存数据和服务器上数据的一致性

- 用户请求数据时，请求的数据可以是存储在服务器上的数据。服务器通常负责处理用户请求，并从存储层（如数据库、文件系统等）获取数据，然后将响应返还给用户。
- 保证本地缓存数据和服务器上数据一致性
  - 失效策略和过期时间。为每个缓存项设置一个合理的过期时间。当缓存项的过期时间到达后，缓存将会自动失效，并通过发送请求到服务器来获取最新数据。
  - 异步更新和延时双写：在进行数据更新时，可以采用异步的方式进行更新。即使服务器上的数据和缓存数据在一段时间内不一致，也可以通过其他的机制（如定期或实时的刷新）来保证数据最终一致性。



9. 代理和反向代理有什么区别代理和适配器模式有什么区别

- 代理模式是为了控制和增强对实际对象的访问，并提供额外的功能。它通过代理对象与客户端进行交互，代表客户端操作真实对象。
- 反向代理是一种网络架构模式，隐藏了服务器并接受客户端的请求，将请求转发给后端的多个服务器。它提供负载均衡、缓存和安全性等功能。Nginx？
- 适配器模式是为了解决不兼容的接口或类之间的问题。它通过适配器将原本不兼容的类转换为目标接口，使其能够协同工作。

























































