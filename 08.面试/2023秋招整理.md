# 58 同城

## 01

公司正在进行优秀项目组评比的初选工作，评委会已经根据 K个项目组提交的材料完成打分，各项目组分数为S1,S2,S3...Sk。

评委会希望设定一个初级晋级分数线x，使得所有得分大于x的项目组晋级，其他淘汰，同时，希望晋级和淘汰的项目组数量都在 [m,n] 区

间。显然 x 可能不存在，也可能存在多个 x。若不存任则输出 -1，若存在多个，则输出满足条件的所有分数线的最小值。





## 02

给定一个从 0 开始的数组 nums 和一个非负整数 k。在一次操作中，你可以做以下操作：

选择一个之前未选择过的下标 i，范围为 [0,nums.length - 1]。

将 nums[i] 替换为范围 [nums[i]-k, nums[i]+k]内的任意整数（包含两端）。

在应用任意次数的操作后，返回数组nums的最大可能分数。数组分数是数组中最多的重复元素个数。

注意，你只能对每个下标应用一次操作。

```
输入
[4,6,1,2],2
输出
3
```





## 03

例如，一个序列可抽象为 “AABCCD”，识别横式为“CCD”，由于"CCD”是序“AABCCD” 的子序列，则表示模式匹配，即可对黑产账号进行处置。

现在，给你一些序列和识别模式，请你找出该序列有多少个这样的子序列。如果子序列不存在则返回0。

```sh
输入
"ABC","A"
输出
1
```



## 面试

算法题：给一个字符串判断里面的三种括号是否正确匹配



### 01 门头沟计算机0922（40分钟）

自我介绍、成绩排名

实习内容

1. hashmap数据结构，为什么要用红黑树

```
用于存储键值对
当我们插入或查询一个键值对时，HashMap 首先通过哈希函数计算出键的哈希值，然后根据哈希值确定该键值对在数组中的位置。
通常情况下，我们会使用数组的索引来直接访问对应位置的元素。然而，在某些情况下，多个键的哈希值可能会冲突，导致它们被映射到数组的同一位置上。这种情况下，我们需要解决哈希冲突。
使用链表来连接相同哈希值的键值对。然而，如果链表过长，会导致查询效率下降，因为需要遍历整个链表才能找到目标键值对。为了解决这个问题，当链表长度超过一定阈值时，HashMap 会将链表转换为红黑树。
红黑树相比链表，在插入、删除和查找操作上具有更高的效率。因为红黑树是自平衡的二叉搜索树，它的插入、删除和查找操作的时间复杂度都是O(log n)，而链表的时间复杂度是O(n)。所以当链表较长时，将其转换为红黑树可以提高 HashMap 的性能。

总而言之，红黑树在 HashMap 中被用作链表的替代结构，用于解决键哈希冲突时的性能问题，提高了查找效率。
```



2. concurrenthashmap数据结构

```
ConcurrentHashMap 是 Java 中的一个线程安全的哈希表实现。它是 HashMap 的线程安全版本，主要用于在多线程环境下进行并发操作。

数据结构基本上和 HashMap 类似，都是通过一个数组来存储键值对。不过，ConcurrentHashMap 在内部使用了一种叫做分段锁（Segment）的机制来实现线程安全。

ConcurrentHashMap 将整个数据结构分成了多个段（Segment），每个段相当于一个小的哈希表。在每个段内部，通过加锁的方式来保证线程安全，不同的段之间可以并发地进行操作，从而提高了并发性能。

并提供了一定的一致性和原子性保证。
```





3. mysql的索引介绍一下

```
索引是数据库中用于提高查询性能的重要机制之一。是一种特殊的数据结构，它可以帮助数据库系统快速定位和访问表中的数据。

MySQL 支持多种类型的索引：
B-Tree 索引：B-Tree（平衡树）是一种常用的索引结构。它可以以有序的方式存储索引数据，并且能够快速进行数据的查找、插入和删除操作。在 MySQL 中，默认情况下，主键（Primary Key）和唯一索引（Unique Index）都是使用 B-Tree 索引来实现的。

哈希索引：哈希索引是将关键字通过哈希函数计算，然后存储在哈希表中。通过哈希索引可以快速获取到具有特定哈希值的记录。但是哈希索引只适用于等值查询，对于范围查询的效果不好。在 MySQL 中，只有 MEMORY 引擎支持哈希索引。

全文索引：全文索引是一种用于全文搜索的索引类型。它可以在文本字段中快速匹配关键词，提供高效的文本搜索功能。在 MySQL 中，只有基于 MyISAM 引擎的表支持全文索引，而 InnoDB 引擎可以使用全文搜索插件来实现类似的功能。

创建索引时需要权衡索引的性能提升和对数据操作的影响。索引可以加快数据的检索速度，但在插入、更新和删除数据时需要额外的时间和空间开销。
```



4. 有个电话系统 如何判断打来的电话不是空号(我说的数据格式校验和布隆过滤器，面试官说还有没有其他的我想不出来了)

```
数据格式校验\布隆过滤器

号码归属地查询：通过将打来的电话号码进行号码归属地查询，可以判断该电话号码是否属于有效的号码段。这种方法需要使用第三方的号码归属地数据库或API来进行查询。

拨打验证：通过真实拨打打来的电话号码，观察是否能够成功连接对方。

查询运营商返回结果：可以通过与运营商系统进行交互，查询该电话号码的状态。运营商会提供一个接口或服务来查询电话号码的是否有效、状态是否正常等信息。
```



```
是的，布隆过滤器可以用于判断打来的电话号码是否为空号。

布隆过滤器是一种快速且高效的概率型数据结构，用于判断一个元素是否存在于一个集合中。它通过使用一系列的哈希函数和一个位数组来实现。具体操作如下：

1. 初始化：需要确定布隆过滤器的大小和哈希函数的个数。同时，需要创建一个位数组，并将所有的位都初始化为0。

2. 添加元素：当有一个电话号码打来时，将该电话号码通过多个哈希函数得到多个哈希值，然后将位数组中对应位置上的位设置为1。

3. 查询元素：当有电话号码打来时，也通过多个哈希函数得到多个哈希值，然后检查位数组中对应位置上的位是否都为1。若存在任何一个位置上的位为0，则可以判断该电话号码不在布隆过滤器所代表的集合中，即该电话号码可能是空号。

布隆过滤器的优点是快速且占用空间相对较小，可以处理大规模数据集合的查询，并且查询速度非常快。但布隆过滤器也存在一定的缺点，主要是存在一定的误判率（即某些不在集合中的元素也可能被误认为在集合中）。

使用布隆过滤器进行电话号码空号判断时，可以逐步添加已验证的电话号码，并在每次来电时查询布隆过滤器判断号码是否为已添加的号码。这样可以快速地判断号码是否是空号，避免进行不必要的查询请求。

需要注意的是，布隆过滤器无法提供确定性的结果，只能提供概率性的结果。因此，在使用布隆过滤器进行电话号码空号判断时，可能会存在一定的误判率。
```



5. sql优化是怎么进行的？

```
SQL 优化是对 SQL 查询语句进行调整和优化，以提高数据库查询性能的过程。以下是一些常见的 SQL 优化技巧：

索引优化：通过合理创建和使用索引，可以大大提高数据库查询的性能。使用索引可以减少数据的扫描和比较，加快数据的检索速度。需要根据具体查询需求和数据访问模式来选择合适的索引类型、创建正确的索引，以及避免过多的索引和索引失效等问题。

查询语句优化：优化查询语句本身是提高查询性能的关键。可以通过优化查询的写法，减少不必要的计算和扫描操作，合理使用关键词、条件和筛选顺序等等。例如，使用合适的 JOIN 语句代替子查询、使用 UNION ALL 代替 UNION、避免使用 SELECT * 等都可以提高查询效率。

避免全表扫描：尽量避免对整个表进行全表扫描，因为全表扫描需要消耗大量的时间和资源。可以通过合理的索引、使用 WHERE 子句和 LIMIT 关键词等方式来限制查询范围，减少扫描数据量。

数据库分区：对于大型数据库或者数据量很大的表，可以考虑对数据进行分区。通过分区可以将数据分散存储在不同的物理文件中，减少查询范围，提高查询性能。

缓存查询结果：对于一些频繁被查询的数据，可以考虑缓存查询结果。通过缓存可以避免重复查询，降低数据库的负载，提高查询的响应速度。

定期优化和维护：定期进行数据库的优化和维护是保持数据库性能的重要手段。可以通过数据库统计信息的收集、索引重建和碎片整理等操作来提高数据库的性能。
```



6. redis数据结构用过哪些 怎么用的？

```
Redis 是一种基于内存的高性能键值数据库，支持多种数据结构。下面介绍一些常用的 Redis 数据结构及其使用方式：

字符串（String）：用于存储字符串类型的值。可以用于缓存、计数器等场景。使用 SET 命令设置值，GET 命令获取值。

哈希（Hash）：用于存储键值对的无序散列表，每个键都对应一组字段和值。适用于存储对象属性。使用 HSET 命令设置键值对，HGET 命令获取对应值。

列表（List）：按照插入顺序存储的字符串元素集合。适用于消息队列、简单日志等场景。使用 LPUSH 和 RPUSH 命令在左或右端插入元素，使用 LPOP 和 RPOP 命令从左或右端删除元素。

集合（Set）：无序且唯一的字符串集合。适用于标签、好友关系等场景。使用 SADD 命令添加元素，使用 SMEMBERS 命令获取所有元素。

有序集合（Sorted Set）：类似集合，每个元素关联一个分数，按照分数排序。适用于排行榜、时间线等场景。使用 ZADD 命令添加带有分数的元素，使用 ZRANGE 命令按照分数范围获取元素。

Bitmap：位图存储。适用于统计、权限控制等场景。使用 SETBIT 命令设置位，使用 BITCOUNT 命令统计位的个数。

HyperLogLog：基于概率算法的数据结构，用于统计元素的基数（不重复元素的个数）。使用 PFADD 命令添加元素，PFMERGE 命令合并统计结果。

除了上述的数据结构，Redis 还提供了其他一些特殊用途的数据结构，如地理位置（Geospatial）等，可以根据具体的业务需求选择合适的数据结构来存储和操作数据。
```



7. redis哨兵介绍一下 哨兵根据什么来选择新的主节点

```
Redis 哨兵（Sentinel）是 Redis 的一种高可用解决方案，用于监控和管理 Redis 主从复制架构中的节点，并在主节点故障时自动选择新的主节点。它具有以下主要功能：

1. 监控：哨兵通过周期性发送心跳检测命令，实时监控 Redis 主、从节点的健康状态。如果发现主节点故障或从节点数量低于指定数量，哨兵将触发故障转移操作。
2. 自动故障转移：当哨兵检测到主节点失效时，它会从众多的从节点中选择一个合适的节点作为新的主节点。选举的条件包括从节点复制偏移量、优先级等。
3. 配置提供和维护：哨兵会定期检查 Redis 配置，确保节点的配置文件与期望配置一致。如果配置不一致，哨兵会自动将节点配置为正确的值。
4. 通知和提醒：哨兵会通过发布和订阅机制通知客户端应用程序主节点变更和故障转移等重要事件。这允许应用程序能够实时感知节点状态的变化。

哨兵选择新的主节点时，主要根据以下因素进行判断：
1. 优先级：哨兵将根据 Redis 节点的配置文件中设置的优先级来选择主节点。优先级较高的节点更有可能被选举为新的主节点。
2. 从节点的复制偏移量：哨兵会选择复制偏移量最大的从节点作为新的主节点，以确保数据的一致性。
3. 选举时间：如果多个从节点具有相同的优先级和复制偏移量，哨兵会选择最早向哨兵报告主节点故障的从节点作为新的主节点。

需要注意的是，哨兵的选举过程是自动进行的，并且是基于特定规则和算法来进行判断的。哨兵会不断监控节点的健康状态并进行故障转移，以确保 Redis 集群的高可用性和可靠性。
```



8. 一道很简单的sql题

9. 一道很简单的链表算法题（合并有序链表并反转）

反问：表现怎样 面试结果多会出(看二面面试官 会有hr联系)

### 02 中国科学院大学计算机0921

```
1.谈谈对java多线程的理解，可以结合具体的项目，如何处理不同线程返回超时、错误等问题
2.谈谈JVM的内存模型、类加载机制和垃圾回收机制，想到什么说什么。
3.谈谈对SpringBoot的理解，以及对微服务框架是怎么理解的。
4.你自己常用的Redis类型是什么，项目中有用到吗，举个例子
5.谈谈Redis雪崩和穿透的区别
6.谈谈对MySQL的索引的理解
7.知道Redis的持久化吗？有哪些方式？各有什么优缺点。
8.场景题：小内存处理大数据

按照简历问的，写的专业技能的内容，一项一项问的。项目没问。
```

1. 谈谈对java多线程的理解，可以结合具体的项目，如何处理不同线程返回超时、错误等问题

```
多线程

理解：各个线程之间可以并发执行任务，从而实现程序的并发处理能力。多线程可以提高程序的性能和响应速度，但也带来了一些挑战，比如线程安全、并发控制等问题。


处理不同线程返回超时、错误等问题的方法可以根据具体项目需求和场景进行选择，以下是一些常用的方法：：
使用 Future 和 Callable：通过使用 Java 并发包中的 Future 和 Callable 可以实现对线程的监控与控制。Callable 接口可以用来封装要在新线程中执行的任务，Future 接口则可以获取任务的执行结果或取消任务。可以设置超时时间，当任务执行超时，可以通过调用 Future 的 cancel 方法取消任务。

使用 CompletableFuture：Java 8 引入的 CompletableFuture 类可以更方便地处理多线程任务。它支持链式操作，可以通过 thenApply、thenAccept、thenCombine 等方法来处理任务的完成结果、异常情况和超时等操作。

使用定时任务和超时处理：可以使用 Java 定时任务的机制来设置超时时间，在任务超时后进行相应的处理。可以使用 Timer 类或者 ScheduledExecutorService 接口来实现。

使用线程池：使用线程池可以更好地管理和复用线程资源，同时可以限制并发数，控制线程的执行和资源消耗。可以使用 ThreadPoolExecutor 类来创建和管理线程池，设置超时时间和错误处理等。

通过中断机制：线程间可以通过中断标志来进行通信和中断处理。可以通过调用线程的 interrupt 方法来设置中断标志，然后在线程内部检查中断标志，及时响应中断信号并进行相应的处理。
```

2. 谈谈JVM的内存模型、类加载机制和垃圾回收机制，想到什么说什么。

```
当谈到 JVM 的内存模型、类加载机制和垃圾回收机制时，以下是一些相关的概念和要点：

1. 内存模型：JVM 的内存模型定义了程序运行时所需的内存布局和访问规则。主要包括栈（Stack）、堆（Heap）、方法区（Method Area/CMS）、程序计数器（Program Counter）和本地方法栈（Native Method Stack）等。栈用于存储方法调用和局部变量，堆用于存储对象实例，方法区用于存储类信息和常量池，程序计数器用于记录当前线程的执行位置，本地方法栈用于支持 native 方法的执行。

2. 类加载机制：Java 类加载机制负责将编译后的字节码文件加载到 JVM 中并进行解析和初始化。类加载器（ClassLoader）负责加载类文件，它分为启动类加载器、扩展类加载器和应用程序类加载器等。类加载过程包括加载、链接（验证、准备、解析）和初始化三个阶段。加载阶段将字节码加载到内存，链接阶段对字节码进行验证、准备内存和解析符号引用，初始化阶段执行静态变量赋值和静态代码块。

3. 垃圾回收机制：JVM 的垃圾回收机制负责自动回收不再使用的对象所占用的内存空间，以便为新的对象提供内存。垃圾回收通过检测对象的可达性来判断对象是否需要被回收。主要的垃圾回收算法包括标记-清除（Mark-Sweep）、复制（Copying）、标记-整理（Mark-Compact）等。常见的垃圾回收器包括串行收集器（Serial）、并行收集器（Parallel）、CMS 收集器（Concurrent Mark Sweep）和 G1 收集器（Garbage First）等。其中，G1 收集器是一种面向大内存、高并发应用场景的垃圾回收器。

除了以上提到的概念，JVM 的内存模型涉及到堆内存和栈内存的分配、对象的引用和引用计数等概念。类加载机制还包括类加载器的双亲委派模型和破坏双亲委派模型的方式。垃圾回收机制还涉及到垃圾回收算法的选择、GC 日志分析和调优等方面。

总之，JVM 的内存模型、类加载机制和垃圾回收机制是 Java 程序运行的基础，并且对程序性能和稳定性有着重要影响。深入理解和掌握这些概念将有助于开发人员编写高效、可靠的 Java 应用程序。
```

3. 谈谈对SpringBoot的理解，以及对微服务框架是怎么理解的。

```
Spring Boot 是一个用于简化和加速构建基于 Spring 框架的应用程序的开发框架。它提供了诸多开箱即用的特性和约定。
对于 Spring Boot 的理解，可以总结为以下几个关键点：

1. 简化配置：Spring Boot 提供了丰富的自动配置，减少了繁琐的配置工作。通过约定大于配置的原则，开发者可以少量甚至无需编写配置，而是通过约定好的命名、注解和默认值来完成配置。

2. 内嵌容器：Spring Boot 可以将应用程序打包为包含内嵌容器（如 Tomcat、Jetty 或 Undertow）的可执行 JAR 文件，使得应用程序可以独立运行，而无需依赖外部容器的安装和配置。

3. 自动化依赖管理：Spring Boot 提供了强大的依赖管理能力。通过 Starter 依赖，开发者可以方便地引入所需的模块和第三方库，而无需手动解决依赖冲突和版本兼容性问题。

4. 微服务支持：Spring Boot 是构建微服务架构的理想选择。它提供了对微服务相关技术（如服务注册与发现、负载均衡、断路器、配置中心等）的支持，并与 Spring Cloud 生态系统无缝集成，使得开发者可以轻松构建和管理分布式、可伸缩、高可用的微服务架构。

对于微服务框架的理解，它是一种将复杂的单体应用拆分为一系列小型、独立的服务的架构设计风格。每个服务都有自己的独立部署、扩展和维护。微服务框架通过服务间的通信和解耦，并采用适当的技术和工具来管理服务的发现、负载均衡、熔断、配置等问题，从而实现高可用性、弹性和可伸缩性。

微服务框架提供了一些核心特性，如服务注册与发现、服务网关、服务间通信、负载均衡、熔断机制等。Spring Cloud 是一个基于 Spring Boot 的开源微服务框架，它为开发者提供了一整套的微服务工具和组件，如 Eureka、Zuul、Feign、Ribbon、Hystrix 等，简化了微服务架构的开发和部署。

通过使用 Spring Boot 和 Spring Cloud，开发者可以更加便捷地构建和管理微服务架构，实现更高效、可扩展的应用程序开发。
```

4. 见前面的

5. 谈谈Redis雪崩和穿透的区别

```
Redis 雪崩和穿透是两种常见的 Redis 缓存相关问题，它们的区别如下所示：

1. Redis 雪崩（Cache Avalanche）：
   - 定义：Redis 雪崩是指在某个时间段内，缓存中的大量数据同时过期或失效，导致大量的请求直接访问数据库或其他下游服务，从而使得数据库或服务出现瞬时的高负载情况。
   - 原因：常见的引发 Redis 雪崩的原因有：a）缓存数据的相对过期时间设置不合理，导致大量缓存同时失效；b）服务器宕机、故障等导致缓存集体失效；c）缓存层面的故障、错误配置等导致大量误读缓存。
   - 影响：Redis 雪崩会造成应用程序性能下降、数据库负载激增甚至崩溃，导致系统不可用。
   - 预防和应对策略：可采取的预防措施包括设置合理的缓存过期时间、加入随机性等；应对策略包括添加缓存锁、限流、熔断降级、多级缓存等。

2. Redis 穿透（Cache Penetration）：
   - 定义：Redis 穿透是指恶意的或者非法的请求绕过缓存直接访问底层存储（比如数据库），导致缓存无效，从而增加了数据库的负载。
   - 原因：Redis 穿透通常是因为请求所对应的数据在缓存中不存在，而且被频繁请求，导致每次请求都绕过缓存并直接访问底层存储。这种情况下，缓存无法发挥作用，导致数据库成为请求的瓶颈。
   - 影响：Redis 穿透会增加数据库的查询负载，可能导致数据库压力过大，甚至耗尽系统资源。
   - 预防和应对策略：可采取的预防措施包括使用布隆过滤器（Bloom Filter）对请求进行过滤，将不存在的数据快速拦截；在缓存层设置空对象缓存；针对频繁请求的热点数据，可以设置永不过期的缓存等。

总结来说，Redis 雪崩是大量缓存同时失效导致请求直接访问底层存储，而 Redis 穿透则是请求绕过缓存直接访问底层存储。两者的影响和防范策略也不同，因此在设计和使用 Redis 缓存时，需要针对这些问题进行适当的预防和应对措施。
```

6. MySQL的索引：见前面的
7. 知道Redis的持久化吗？有哪些方式？各有什么优缺点。

```
是的，Redis 提供了持久化机制，用于将内存中的数据以某种方式保存到硬盘上，以便在 Redis 重新启动时恢复数据。Redis 的持久化主要有两种方式：RDB（Redis Database）和 AOF（Append-Only File）。

1. RDB 持久化：
   - 原理：RDB 持久化通过将 Redis 在某个时间点的数据快照写入磁盘，即在指定的时间间隔内生成一个 RDB 文件，该文件包含了 Redis 在这段时间内的数据集合。默认情况下，RDB 文件会覆盖先前的文件。
   - 优点： RDB 的优点包括：a）适用于大规模的数据集，适合进行备份和恢复；b）生成的 RDB 文件紧凑，对硬盘占用小；c）启动时加载 RDB 文件，恢复速度较快。
   - 缺点：RDB 的缺点包括：a）在 Redis 关闭异常时（如进程退出或崩溃），可能会导致数据丢失；b）需要频繁进行快照操作，在某些情况下可能会降低 Redis 的性能。

2. AOF 持久化：
   - 原理：AOF 持久化记录了每个写操作在执行时对内存状态的改变，以追加写的方式将命令写入 AOF 文件中。通过回放 AOF 文件中的命令，Redis 可以在重启时重新构建数据集。
   - 优点：AOF 的优点包括：a）适用于需要高可靠性的应用，提供更好的数据持久化保护；b）AOF 文件以易读的方式记录数据修改命令，方便人们阅读、恢复；c）可以通过配置 AOF 文件的 fsync 策略来保证数据持久化的安全性和性能。
   - 缺点：AOF 的缺点包括：a）AOF 文件通常比 RDB 文件更大；b）AOF 文件需要频繁地追加写入数据，对磁盘的写入性能有一定影响；c）AOF 文件相对于 RDB 文件的恢复速度较慢。

需要注意的是，RDB 和 AOF 可以同时启用，以提供更高的数据可靠性。可以通过配置 Redis 的持久化机制来选择合适的选项。RDB 适合用于备份和快速恢复数据，而 AOF 适合用于需要更精确恢复点和更好的数据安全性的场景。
```

8. 场景题：小内存处理大数据

```
在处理大数据时，如果面临内存有限的情况下，可以考虑以下一些策略和技术：

1. 分批处理：将大的数据集分割成更小的批次进行处理，每次只加载和处理一部分数据，避免一次性加载整个数据集导致内存溢出。可以使用分页查询或迭代器等方式来实现分批处理。

2. 压缩存储：针对大规模数据集，可以考虑使用压缩算法将数据进行压缩，减少内存的占用。一些常见的数据压缩格式如 GZIP、Snappy、LZ4 等，可以根据实际情况选择合适的压缩算法。

3. 数据持久化：将数据存储到磁盘等持久化介质中，而不是完全依赖内存。可以使用数据库、文件等方式进行数据持久化存储，在需要时进行读取和处理。

4. 建立索引：对于需要频繁查询的数据，可以建立索引来加速查询。索引可以减少对整个数据集的扫描，提高查询效率，从而减少内存的占用。常见的索引类型包括哈希索引、B树索引等。

5. 剔除冗余数据：对于大数据集中的冗余数据，可以进行数据清洗和去重，减少数据的冗余度和重复性，从而减少内存的占用。

6. 数据分布式处理：如果单台机器处理大数据已经无法满足需求，可以考虑采用分布式计算框架，如 Apache Hadoop、Apache Spark 等，将数据分布到多台机器上进行并行处理，以提高处理效率。

需要根据具体的业务场景和数据特点来选择合适的策略和技术，并结合硬件资源和性能要求来进行优化。同时还需要注意数据的完整性和一致性，并进行有效的测试和评估。
```



### 03 中海洋计算机0922

自我介绍

多个字符串最长公共前缀

简单问了点项目，不太感兴趣就没深挖

```
1.tcp，udp，ip
2.两台设备通信怎么知道穿的数据是给哪一个应用程序的
3.数据库索引
4.快排的原理
5.进程线程的区别，通信方式
6.互斥锁和读写锁
```

反问

1. tcp，udp，ip

```
TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）和IP（Internet Protocol）都是互联网协议族的重要协议，用于实现网络通信。

1. IP（Internet Protocol，互联网协议）：
   - 作用：IP 是一种网络层协议，负责在互联网上传输数据包（数据的基本单位）。
   - 特点：IP 协议是面向无连接的，每个数据包都是独立处理的，在传递过程中可能发生丢包、延迟和乱序。
   - 功能：IP 地址作为唯一标识，用于寻址和路由，从源地址到目的地址进行转发。

2. TCP（Transmission Control Protocol，传输控制协议）：
   - 作用：TCP 是一种面向连接的、可靠的传输层协议，用于在网络上传输数据。
   - 特点：TCP 提供面向连接的通信，确保数据可靠交付，具有流控制和拥塞控制等机制。通过三次握手建立连接以及四次挥手终止连接。
   - 功能：拥有可靠的数据传输，保证按顺序接收和重组数据包。

3. UDP（User Datagram Protocol，用户数据报协议）：
   - 作用：UDP 是一种面向无连接的传输层协议，用于在网络上传输数据。
   - 特点：UDP 不保证数据可靠性和按顺序传输，没有拥塞控制机制，传输效率较高。
   - 功能：UDP 提供基本的数据传输服务，适用于实时应用或数据包丢失对应用性能影响较小的场景，如音频、视频流传输等。

总结来说，IP 是互联网协议族中的网络层协议，负责将数据包从源地址传递到目的地址。TCP 是一种面向连接、可靠的传输层协议，提供可靠的数据传输和流控制等机制。UDP 是一种面向无连接的传输层协议，不保证可靠性，适用于传输实时数据和对可靠性要求较低的场景。这三个协议在互联网通信中各有不同的应用和特点。
```

2. 两台设备通信怎么知道穿的数据是给哪一个应用程序的

```
在两台设备之间的通信中，要确保数据传递给正确的应用程序，可以使用以下方式来识别数据的目标应用程序：

1. 端口号：每个应用程序在设备上都会使用一个唯一的端口号。发送方可以将数据发送到目标设备的特定端口号，并且接收方的操作系统会将数据发送到该端口号对应的应用程序上。

2. IP 地址：每个设备在网络上都会被分配一个唯一的 IP 地址。发送方可以将数据发送到目标设备的 IP 地址，并且接收方的操作系统会将数据发送到该 IP 地址所在的设备上。

3. 协议标识：在数据传输中，通常会使用特定的协议来标识数据的目标应用程序。例如，HTTP 使用特定的端口号（如80或443）和协议标识来传递网页数据。

综合考虑端口号、IP 地址和协议标识，两台设备之间的通信可以通过这些信息来正确识别数据的目标应用程序。发送方必须确保将数据发送到正确的端口号和 IP 地址，并使用适当的协议标识来确保数据能够被接收方正确处理。接收方则根据端口号和协议标识将数据路由给目标应用程序。
```

3. 数据库索引：见前面
4. 快排的原理

```
快速排序（Quicksort）是一种常用的排序算法，采用分治法策略实现。它的基本原理如下：

1. 选择一个基准元素（pivot），通常选择数组中的第一个元素或者随机选择。
2. 将数组分割成两个子数组，使得左边的元素都小于等于基准元素，右边的元素都大于基准元素。这个过程称为分区（Partition）。
3. 对左右两个子数组递归执行步骤 1 和步骤 2，直到子数组的大小为 1 或者 0，此时数组已经有序。

具体的分区过程如下：

1. 设定左指针为起始位置（第一个元素），右指针为结束位置（最后一个元素）。
2. 将基准元素存储在一个临时变量中，空出基准元素的位置。
3. 从右指针开始，向左遍历，找到一个小于基准元素的元素。
4. 从左指针开始，向右遍历，找到一个大于基准元素的元素。
5. 交换左右指针对应的元素，使得小于基准元素的元素位于左边，大于基准元素的元素位于右边。
6. 重复步骤 3 和步骤 4，直到左指针和右指针相遇。
7. 将基准元素放回到当前左指针的位置，完成一次分区操作。

通过不断递归执行上述步骤，最终实现对整个数组的排序。

快速排序的时间复杂度为 O(nlogn)，其中 n 表示数组的大小。它是一种原地排序算法，不需要额外的存储空间，具有较高的效率和普适性。然而，在某些情况下（如基准元素选择不当），快速排序可能退化为 O(n^2) 的时间复杂度，因此可以通过随机选择基准元素或优化的分区策略来提高算法的性能。
```

5. 进程线程的区别，通信方式

```
进程（Process）和线程（Thread）是操作系统中进行任务调度的基本单位。

区别：
1. 资源占用：进程是独立的内存空间和资源集合，每个进程有自己的地址空间、文件描述符、打开的文件等。而线程是在进程内部执行的，共享相同的内存空间和资源。多个线程可以共享同样的数据和上下文，节约了资源。
2. 调度和切换：进程由操作系统进行调度和分配资源，具有独立的执行流。线程是由操作系统内核调度的，它是在一个进程内的不同执行路径。线程切换更快，代价更低。
3. 独立性：进程之间是相互独立的，一个进程的崩溃不会影响其他进程。而线程是在同一个进程内执行，共享同一进程的上下文和资源。一个线程的错误可能导致整个进程的崩溃。

通信方式：
进程间通信（Inter-Process Communication，IPC）和线程间通信（Inter-Thread Communication，ITC）是实现进程和线程之间数据共享和协调的方式。

1. 进程间通信：
    - 管道（Pipe）：提供半双工的通信方式，通信双方需要有亲缘关系，如父子进程。
    - 共享内存（Shared Memory）：将某块内存区域映射到多个进程的地址空间，实现数据共享。
    - 信号量（Semaphore）：用于进程同步和互斥。
    - 消息队列（Message Queue）：实现进程间的异步通信。
    - 套接字（Socket）：通过网络通信实现进程间通信。

2. 线程间通信：
    - 锁机制：如互斥锁（Mutex）和读写锁（ReadWrite Lock）等，用于保护共享资源的访问。
    - 条件变量（Condition Variable）：用于线程的等待和唤醒机制。
    - 信号量（Semaphore）：用于线程间的信号通知和同步。
    - 屏障（Barrier）：等待一组线程达到某个状态，再同时执行下一步操作。

需要根据具体的情况和需求，选择合适的通信方式来实现进程或线程之间的数据交换和同步。
```

6. 互斥锁和读写锁

```
互斥锁（Mutex）和读写锁（ReadWrite Lock）都是常见的线程同步机制，用于保护共享资源的访问。它们的主要区别在于对于多读单写场景的处理方式。

1. 互斥锁（Mutex）：
   - 互斥锁是一种二进制信号量，用于保证在同一时间只有一个线程可以访问共享资源。
   - 当一个线程获得了互斥锁后，其他线程需要等待该锁被释放，才能继续访问共享资源。
   - 互斥锁适用于解决互斥问题，即多个线程之间的竞争条件。

2. 读写锁（ReadWrite Lock）：
   - 读写锁是一种多进制信号量，允许多个线程同时读取共享资源，但当有线程需要写入时，写锁会独占资源。
   - 多个线程可以同时获得读锁，只要没有线程持有写锁，以实现并发读取操作。
   - 写锁是互斥的，当一个线程获得写锁后，其他线程无法读取也无法写入，直到写锁被释放。
   - 读写锁适用于解决多读单写问题，可以提高读操作的并发性能。

适用场景：
- 如果读操作比较频繁，而写操作相对较少，读写锁可以有效提升性能，允许并发读取。
- 如果读写操作都很频繁，使用互斥锁可能更适合，避免读写冲突和数据不一致的问题。
- 注意，在使用读写锁时，需要确保对共享资源的读写操作是安全的，以避免出现竞态条件。

需要根据具体的场景和需求选择合适的同步机制，互斥锁和读写锁都是常见且有效的线程同步工具，可以根据实际情况选择适合的机制。
```







### 04 石家庄铁道大学计算机0922（不到30分钟）、哈工大

更多是Java基础

```
双亲委派机制
类加载流程
Java内存模型
好多jvm相关问题忘了
线程怎么启动，start方法调用两次发生什么？直接调用run方法？
sleep和awit区别
cas是什么，会有什么问题
线程池参数，阻塞队列选择无界还是有界，会有什么问题
计算机网络tcp和http区别
MySQL事务，保证原子性的原理
MySQL索引结构，b树和B+树区别
执行一条查询sql（for update），是否会用到锁，用到什么锁
Redis主从原理是什么
Redis缓存淘汰策略
熟悉的数据结构
说快排思路，原理（递归+分治）
LRU算法了解吗，有什么实现思路
```



1. 双亲委派机制

```
双亲委派机制（Parent Delegation Model）是Java类加载器（ClassLoader）的一种工作机制。它是一种层次化的类加载机制，通过委派的方式来保证类的唯一性和安全性。

在双亲委派机制中，每个类加载器都有一个父类加载器，当一个类加载器接收到类加载请求时，它会首先将这个请求委派给它的父类加载器，直到最顶层的启动类加载器。只有在父类加载器无法找到并加载所需的类时，才会由当前类加载器自己来完成类加载操作。

这种机制的好处包括：

1. 类的唯一性：双亲委派机制可以确保类在整个Java虚拟机中是唯一的。当一个类被加载后，它会向上委派给其父类加载器，因此在整个类加载器层次结构中只会存在一个相同的类。

2. 安全性：通过双亲委派机制，Java类库的核心类会由启动类加载器来加载，这些类经过严格测试和验证，保证了核心类库的安全性。而自定义的类则是由应用类加载器来加载，可以避免核心类库被恶意篡改。

3. 避免重复加载：当一个类加载器发现有类需要加载时，它会委派给父类加载器进行加载操作，如果父类加载器已经加载过这个类，就可以直接使用，避免了重复加载。

总结来说，双亲委派机制通过层次化的类加载器结构，保证了类的唯一性、安全性和更高效的加载。它是Java虚拟机实现类加载的一种常见机制，并且可以通过自定义类加载器来覆盖默认的双亲委派机制。
```

2. 类加载流程

```
在Java中，类加载是将类的字节码文件加载到内存中，并进行相关的验证、准备和初始化的过程。类加载的流程如下：

1. 加载（Loading）：类加载的第一阶段是加载，即通过类加载器将字节码文件加载到内存中，并创建相应的Class对象表示该类。加载阶段包括以下步骤：
   - 通过类的全限定名找到相应的字节码文件。
   - 将字节码文件读取到内存，并创建Class对象表示该类。

2. 验证（Verification）：在验证阶段，对加载的字节码进行验证，确保它满足Java虚拟机的规范和安全要求。验证阶段包括以下内容：
   - 文件格式验证：检查字节码文件是否符合Class文件规范。
   - 元数据验证：对字节码中的各个符号引用进行验证。
   - 字节码验证：对字节码中的数据流进行分析和验证。

3. 准备（Preparation）：准备阶段是为类的静态变量分配内存，并设置其默认初始值。准备阶段包括以下步骤：
   - 为静态变量分配内存空间，并将其初始化为默认值（0、null、false等）。
   - 在方法区中创建方法表，包括静态变量和方法的信息。

4. 解析（Resolution）：解析阶段是将符号引用解析为直接引用。符号引用是一种符号表示的形式，直接引用是直接指向目标的指针、偏移量或句柄。解析阶段包括以下工作：
   - 类或接口符号引用解析为对应的直接引用。
   - 字段符号引用解析为字段的内存偏移量。
   - 方法符号引用解析为方法的直接引用。

5. 初始化（Initialization）：在初始化阶段，对类的静态变量赋予正确的初始值，并执行类的静态代码块（static块）中的代码。初始化阶段包括以下步骤：
   - 根据程序对类的主动使用（例如创建对象或访问静态字段）触发初始化。
   - 执行静态变量的赋值操作和静态代码块中的代码。

需要注意的是，类的加载过程一般是在需要使用该类时才会触发，Java虚拟机使用了延迟加载的策略。

以上是类加载的基本流程，每个阶段都会进行相应的操作和检查，确保类的正确加载和初始化。
```



5. 线程怎么启动，start方法调用两次发生什么？直接调用run方法？

在Java中，线程的启动通常通过调用线程对象的 `start()` 方法来实现。

1. 线程的启动：通过 `start()` 方法启动一个线程会执行以下操作：
   - 线程进入就绪状态，等待系统调度。
   - 系统在适当的时机选择线程，并调用其 `run()` 方法。

2. `start()` 方法调用两次的情况：如果对同一个线程对象多次调用 `start()` 方法，会导致 `IllegalThreadStateException` 异常的抛出，表示线程状态异常。一个线程只能启动一次，多次调用 `start()` 是不允许的。

3. 直接调用 `run()` 方法：直接调用线程对象的 `run()` 方法，并不会启动新的线程，而是相当于普通的方法调用。线程的代码会在当前线程中同步执行，不会创建新的线程并进行并发执行。

需要注意的是，使用 `start()` 方法启动线程可以实现多线程并发执行，而直接调用 `run()` 方法只会在当前线程中同步执行，并不会实现多线程效果。

示例代码：

```java
class MyThread extends Thread {
    public void run() {
        // 线程执行的代码
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程
    }
}
```

在上述示例中，调用 `thread.start()` 启动线程，会触发线程的就绪状态，并在适当的时机执行线程的 `run()` 方法。而直接调用 `thread.run()` 则只会在当前线程中同步执行 `run()` 方法的代码。



6. sleep和awit区别

````
`sleep()` 和 `wait()` 是 Java 中用于线程间协作的方法，它们有以下几点区别：

1. 所属对象不同：
   - `sleep()` 是 Thread 类的静态方法，可以直接调用。
   - `wait()` 是 Object 类中的方法，需要在同步代码块或同步方法中调用。调用 `wait()` 前需要先获得对象的锁。

2. 使用的方式不同：
   - `sleep()` 方法让当前线程暂停执行指定的时间段，不会释放占有的锁。
   - `wait()` 方法让当前线程暂停执行，同时释放对象的锁，使得其他线程可以获得锁并执行。

3. 唤醒条件不同：
   - `sleep()` 方法会在指定的时间过后自动唤醒，或者被其他线程中断时会抛出 `InterruptedException`。
   - `wait()` 方法会一直等待，直到其他线程调用对象的 `notify()` 或 `notifyAll()` 方法来唤醒等待的线程。

4. 使用场景不同：
   - `sleep()` 通常用于暂停当前线程，可以用于模拟耗时操作，或者控制线程执行的时间。
   - `wait()` 用于线程间的协作。在多线程的情况下，当某个线程等待某个条件满足时，可以调用 `wait()` 方法将该线程挂起，等待其他线程改变条件并调用 `notify()` 或 `notifyAll()` 来唤醒等待的线程。

需要注意的是，`wait()` 和 `notify()` 必须在同步代码块或同步方法中使用，因为它们需要先获取对象的锁。而 `sleep()` 方法可以在任何位置使用，不需要获取锁。

示例代码：

```java
public class Main {
    public static void main(String[] args) {
        Object lock = new Object();
        
        synchronized (lock) {
            try {
                // 线程等待，并释放锁
                lock.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // 使用 sleep() 方法让线程休眠
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

在上述示例中，使用 `wait()` 方法让线程等待并释放锁，而使用 `sleep()` 方法让线程休眠一段时间。
````



7. cas是什么，会有什么问题

```
CAS，即比较并交换（Compare and Swap），是一种并发算法，用于实现多线程环境下的原子操作。CAS操作由三个操作数组成：需要读写的内存位置（通常是共享变量）、旧的预期值和新的值。CAS的操作过程如下：

1. 读取内存位置的当前值。
2. 检查当前值是否等于旧的预期值。
3. 如果相等，将内存位置的值更新为新的值；如果不相等，则不做任何操作。
4. 返回操作前的旧值。

CAS操作是基于乐观锁的思想，它不像传统锁机制（如 synchronized）一样直接阻塞线程，而是通过比较内存位置的当前值和预期值是否一致来判断是否进行更新。这种方式避免了线程的阻塞与唤醒所带来的开销，提高了并发性能。

然而，CAS操作也存在以下问题：

1. 自旋开销：在高并发情况下，如果多个线程同时执行CAS操作，有时会出现多个线程一起失败并重新尝试的情况，这会增加自旋的开销。

2. ABA问题：CAS只能保证变量的值没有被修改过，但无法保证它的意义没有发生变化。比如，线程1读取变量A的旧值为1，然后线程2将A的值改为2，最后线程2又将A的值改回1，此时线程1执行CAS操作成功，但实际上A的值已发生了改变。

为了解决CAS的这些问题，Java提供了Atomic包，其中的AtomicInteger、AtomicLong等类可保证对变量的原子操作。此外，还可以使用带有版本号的CAS来解决ABA问题，如Java提供的AtomicStampedReference类。

总的来说，CAS是一种高效的并发控制机制，可以提供原子性操作。但需要注意其使用场景，避免出现并发问题。
```



8. 线程池参数，阻塞队列选择无界还是有界，会有什么问题

```
在配置线程池时，可以设置多个参数来影响线程池的行为和性能。其中一个重要的参数是阻塞队列（BlockingQueue）的选择，可以选择无界队列或有界队列。具体选择哪种队列取决于应用程序的需求和预期的行为。

1. 无界队列：
   - 使用无界队列（例如 `LinkedBlockingQueue`）可以保证任务不会被拒绝且不会抛出异常，因为队列可以无限地增长。
   - 优点：适用于处理大量任务且任务执行时间较短的情况，可以避免任务被拒绝。无需考虑队列满的情况下的处理方式。
   - 缺点：当提交的任务速度远远大于处理的速度时，可能会导致队列无限增长，占用大量内存。

2. 有界队列：
   - 有界队列（例如 `ArrayBlockingQueue`）限制了队列的最大容量，超过容量时无法继续向队列中添加任务，可能会触发线程池的拒绝策略。
   - 优点：可以限制任务的数量，避免无限的任务提交，从而控制内存消耗。适用于任务量较小、处理速度较慢、希望对任务数量进行限制的场景。
   - 缺点：当有界队列满时，可能会导致提交的任务被拒绝，需要根据具体情况选择适当的拒绝策略。

需要根据实际情况来选择阻塞队列的类型，平衡任务提交速度、任务执行速度和系统资源之间的关系。

如果任务提交的速度远大于处理速度，无界队列可能会导致系统内存占用过高。而有界队列可以限制任务的数量，使得任务提交速度不会超过处理能力，但可能会拒绝部分任务。

因此，在选择阻塞队列时，需要综合考虑系统负载、任务特点、内存占用等因素，以及对未执行的任务的处理方式，选择合适的阻塞队列类型。
```



9. 计算机网络tcp和http区别

```
TCP（传输控制协议）和HTTP（超文本传输协议）是计算机网络中的两个不同的协议，它们在不同层级上提供了不同的功能和服务。

1. 层级不同：
   - TCP 是位于传输层的协议，负责在网络中可靠地传输数据。它提供了面向连接的、可靠的字节流传输。
   - HTTP 是位于应用层的协议，基于TCP协议，用于在Web上请求和传输超文本文档。它是一种无状态的、无连接的协议。

2. 功能不同：
   - TCP 提供了可靠的数据传输，通过使用序列号、确认和重传机制来确保数据的有序性、完整性和可达性。
   - HTTP 用于在客户端和服务器之间传输超文本文档，它规定了请求和响应的格式以及各种操作（如GET、POST）。

3. 连接性不同：
   - TCP 使用面向连接的方式建立和维护通信双方之间的连接，通过三次握手和四次挥手来确保连接的可靠性。
   - HTTP 是一种无连接的协议，每次请求和响应都是独立的，不保留连接状态。

4. 数据格式不同：
   - TCP 仅提供了原始的二进制数据传输，没有规定数据的具体格式。
   - HTTP 使用特定的消息格式（如请求消息和响应消息），并使用HTML、XML、JSON等格式来表示数据。

5. 适用场景不同：
   - TCP 适用于需要可靠传输的场景，如文件传输、电子邮件传输等。
   - HTTP 适用于Web应用程序中请求资源的场景，如浏览器请求页面、发送表单数据等。

需要注意的是，HTTP协议是基于TCP协议的，它在TCP连接上发送HTTP消息。因此，HTTP依赖于TCP协议来提供可靠的传输。
```



12. 执行一条查询sql（for update），是否会用到锁，用到什么锁

```
当执行一条带有 `FOR UPDATE` 的查询 SQL 语句时，会涉及到数据库的行级锁（Row-level Lock）。

行级锁是数据库中一种细粒度的锁，用于控制对数据库表中具体行的并发访问。当执行一条带有 `FOR UPDATE` 的查询语句时，数据库会在查询过程中对查询结果中的行进行加锁，以防止其他事务对这些行进行修改。

具体而言，`FOR UPDATE` 语句会在查询到符合条件的数据行时，对这些行加上共享锁（S锁）或排他锁（X锁）。加锁的方式取决于数据库系统的实现和事务的隔离级别。

- 共享锁（S锁）：加上S锁后的数据行可以被其他事务读取，但不能被其他事务修改。多个事务可以同时持有共享锁，实现并发读取。
- 排他锁（X锁）：加上X锁后的数据行不允许其他事务读取或修改。只有当前事务可以持有排他锁。

行级锁的使用能够保证在多个事务并发执行时，只有一个事务能够修改被锁定的行数据，从而确保数据的一致性和隔离性。

需要注意的是，行级锁可能会导致其他事务的阻塞等待，如果多个事务之间存在依赖关系，可能会出现死锁的情况。因此，在使用行级锁时，需要谨慎考虑并发性和事务之间的依赖关系，以避免潜在的问题。
```

13. Redis主从原理是什么

```
Redis 主从复制是一种实现数据备份和高可用性的机制。它基于主服务器（Master）将数据同步到一个或多个从服务器（Slave）的原理。以下是 Redis 主从复制的工作原理：

1. 同步初始化：从服务器连接到主服务器请求全量数据同步。主服务器会生成一个 RDB 快照文件，通过网络传输给从服务器。从服务器接收到 RDB 快照文件后进行载入，确保数据与主服务器一致。

2. 增量同步：主服务器会将写命令以消息的形式发送给从服务器。从服务器通过连接池和主服务器保持长连接，接收并执行主服务器的写命令，保持数据的增量同步。

3. 心跳检测：从服务器通过在心跳时间间隔内向主服务器发送 PING 命令来检测主服务器是否在线。如果心跳检测失败，从服务器会尝试重新连接主服务器。

4. 断线重连：当从服务器与主服务器的连接断开时，从服务器会自动重连主服务器，并进行重新同步。主服务器会在断线时保存增量同步的数据，以备从服务器重新连接时使用。

通过主从复制，实现了以下好处：

- 备份与恢复：从服务器保存了主服务器的完整数据副本，可以在主服务器故障时快速恢复数据。
- 负载均衡：读操作可以分摊到多个从服务器上，减轻主服务器的压力，提高系统整体的读取性能。
- 高可用性：即使主服务器发生故障，从服务器可以立即切换为新的主服务器，保证系统的高可用性。

需要注意的是，Redis 主从复制是异步的，主服务器将数据同步到从服务器时存在一定的延迟。此外，在主服务器宕机、网络异常等情况下，从服务器可能会无法及时同步数据，导致主从数据不一致。因此，在使用 Redis 主从复制时，需要根据具体的使用场景和数据一致性的要求来进行配置和监控。
```





14. Redis缓存淘汰策略

```
Redis 是一种内存型缓存数据库，当内存空间不足时，需要使用淘汰策略来决定哪些键会被淘汰出内存，以保证新数据的存储。以下是几种常见的 Redis 缓存淘汰策略：

1. LRU（Least Recently Used，最近最少使用）：选择最近最少被访问的键进行淘汰。这是默认的淘汰策略。适用于数据访问具有局部性的场景。

2. LFU（Least Frequently Used，最不经常使用）：选择最不经常被访问的键进行淘汰。根据键的访问频率进行统计和判断。适用于数据访问具有长期性特征的场景。

3. Random（随机淘汰）：随机选择键进行淘汰。在内存不足时，随机选择一个键淘汰。不依赖于键的访问模式。

4. TTL（Time To Live，设置过期时间）：设置键的时间过期，根据过期时间淘汰。可以通过给键设置过期时间来自动淘汰过期的键。

5. Maxmemory-policy（最大内存策略）：根据存储使用量调整淘汰策略。可以设置当内存达到最大值时，Redis 采取的淘汰策略，如使用 `noeviction` 表示不执行淘汰，只返回错误；或是使用 `allkeys-lru` 表示对所有键使用 LRU 策略进行淘汰。

需要根据具体的业务场景和需求选择适合的淘汰策略。例如，对于访问较为频繁的热点数据可以选择 LRU 策略，对于访问较少的冷数据可以选择 LFU 策略，或者使用过期时间来自动淘汰不再使用的数据。此外，Redis 还提供了手动清除数据的命令，如 `DEL`、`UNLINK` 等，可以根据具体情况手动控制缓存数据的淘汰。
```





### 05 蚌埠 电子信息类

```
1.自我介绍
2.挖项目（吟唱中被直接打断施法）
3.什么情况下加索引
4.你知道的分库分表的工具（不让讲原理，直接说工具，原谅我真的没遇到过这种场景）
5.单表怎么优化，有什么方法
6.你知道的锁都有哪些，Java的，操作系统的等等，详细说说他们之间的关系以及使用场景
7.tcp四次挥手的流程以及状态流转
8.创建线程的方法都有哪些，内置的线程池都是什么，展开说下。
9.知道什么是守护进程吗，讲一下什么是守护进程
```



4. 你知道的分库分表的工具

```
当涉及到分库分表的需求时，有一些常用的工具可供选择，包括：

1. ShardingSphere（原分库分表中间件）：ShardingSphere 是一套开源的分布式数据库中间件解决方案，提供了全面的分库分表功能，支持水平拆分和垂直拆分，并且支持多种数据库。它具有较高的灵活性和可扩展性，能够帮助开发者实现分库分表需求。

2. Vitess：Vitess 是一个由 YouTube 开发并开源的分布式数据库中间件，专门用于 MySQL 数据库的分库分表。它可以将一个大型 MySQL 数据库拆分成多个小型数据库实例，从而提供更好的扩展性和性能。

3. MyCAT（MySQL Cluster Autonomic Tuning）：MyCAT 是一个开源的分布式数据库中间件，专注于 MySQL 数据库的分库分表和读写分离。它提供了水平拆分和垂直拆分的功能，并支持复杂的分片规则。

4. TDDL（Taobao Distributed Data Layer）：TDDL 是专为大规模高并发的电子商务场景而开发的分库分表中间件，由淘宝开发并开源。它提供了水平拆分和垂直拆分的功能，支持 MySQL 和 Oracle 数据库。

这些工具在实现分库分表时提供了不同的特性和灵活性，可以根据具体的需求和技术栈来选择合适的工具。此外，还可以使用一些权衡方案来手动实现分库分表，如自定义数据库路由、使用数据库代理等。
```



7. tcp四次挥手的流程以及状态流转

```
TCP 四次挥手是用于关闭 TCP 连接的过程，确保双方都完成数据传输并释放相关资源。下面是 TCP 四次挥手的流程及状态流转：

1. 第一次挥手（FIN）：
   - 主动关闭方发送一个带有 FIN（Finish）标志的 TCP 报文段给被动关闭方，表示主动关闭方不再发送数据。
   - 主动关闭方的状态从 ESTABLISHED（已建立）变为 FIN_WAIT_1（等待对方的确认）。

2. 第二次挥手（ACK）：
   - 被动关闭方接收到 FIN 报文段后，发送一个 ACK（Acknowledgment）报文段作为确认。
   - 被动关闭方的状态从 ESTABLISHED 变为 CLOSE_WAIT（等待关闭）。

3. 第三次挥手（FIN）：
   - 被动关闭方通过调用 close() 方法发起关闭请求后，发送一个带有 FIN 标志的报文段给主动关闭方。
   - 被动关闭方的状态从 CLOSE_WAIT 变为 LAST_ACK（等待主动关闭方的确认）。

4. 第四次挥手（ACK）：
   - 主动关闭方接收到 FIN 报文段后，发送一个 ACK 报文段作为确认。
   - 主动关闭方的状态从 FIN_WAIT_1 变为 FIN_WAIT_2（等待被动关闭方的确认）。

5. 关闭连接确认：
   - 被动关闭方接收到 ACK 报文段后，将状态从 LAST_ACK 变为 CLOSED（关闭）。
   - 主动关闭方在接收到被动关闭方的 ACK 报文段后，将状态从 FIN_WAIT_2 变为 TIME_WAIT（等待一段时间）。
   - 在等待时间结束后，主动关闭方将状态从 TIME_WAIT 变为 CLOSED。

注意：TIME_WAIT 状态是为了确保在网络中可能存在的延时报文段被接收和处理，防止后续的重复的报文段被错误处理。
```

总结流程如下：
``` 
主动关闭方                被动关闭方
 ESTABLISHED
    |
 FIN_WAIT_1    -->              CLOSE_WAIT
    |                           |
 FIN_WAIT_2   <--              LAST_ACK
    |                           |
  TIME_WAIT   -->               CLOSED
    |                           |
  CLOSED                     CLOSED
```

以上是 TCP 四次挥手的流程及状态流转，确保双方完成数据的传输并安全地关闭连接。



8. 创建线程的方法都有哪些，内置的线程池都是什么，展开说下

```
创建线程的方法主要有以下几种：

1. 继承 Thread 类：创建一个继承自 Thread 类的新类，并重写 run() 方法来定义线程的执行逻辑。使用 start() 方法启动线程。

2. 实现 Runnable 接口：创建一个实现 Runnable 接口的类，并实现其中的 run() 方法。通过创建 Thread 实例，并将实现了 Runnable 接口的类作为参数传递给 Thread 的构造函数，然后调用 start() 方法启动线程。

3. 实现 Callable 接口：创建一个实现 Callable 接口的类，并实现其中的 call() 方法。通过创建 ExecutorService 实例，调用 submit() 方法提交 Callable 对象，将返回一个 Future 对象，可以通过 Future 对象来获取线程执行的结果。

内置的线程池是指 Java 提供的用于管理和复用线程的线程池框架，位于 java.util.concurrent 包下。以下是 Java 提供的常用内置线程池：

1. FixedThreadPool：固定大小线程池，线程数固定，适用于执行长期的任务，限制最大并发数。

2. CachedThreadPool：缓存线程池，线程数根据任务数量动态调整，适用于执行大量短期的任务。

3. SingleThreadPool：单线程池，只有一个工作线程，适用于需要按顺序执行任务的场景。

4. ScheduledThreadPool：调度线程池，可以延迟或定时执行任务。

这些内置线程池提供了方便的线程管理和任务调度的功能，可以避免手动管理线程的复杂性。使用内置线程池可以有效地复用线程对象，减少线程的创建和销毁开销，同时提供了线程池大小的调节和任务队列等特性，能够更好地控制线程的行为和资源消耗。

使用内置线程池时，可以通过 Executors 工厂类的静态方法来创建不同类型的线程池实例，并使用 submit() 方法提交任务，由线程池自动分配线程来执行任务。当不再需要执行任务时，可以关闭线程池来释放资源。
```





9. 知道什么是守护进程吗，讲一下什么是守护进程

```
守护进程（Daemon process）是在计算机操作系统中运行的一种特殊类型的进程。它以后台方式运行，独立于终端或用户会话，并且通常在系统启动时自动启动。

守护进程的主要特点如下：

1. 守护进程在后台运行，与终端或用户会话无关。它不接受来自用户的输入，也不向用户输出信息。
2. 守护进程经常以系统服务的形式存在，提供特定功能或执行特定任务，如网络服务、定时任务等。
3. 守护进程通常在系统启动时由系统初始化或其他进程启动，并在系统运行期间持续运行，直到系统关闭或手动停止。
4. 守护进程通常没有控制终端，因此没有与之交互的直接方式。它们通过系统日志、配置文件或与其他进程进行通信来进行操作和交流。
5. 守护进程可以在后台执行长时间运行的任务，不受用户登录或注销的影响。
6. 守护进程往往具备持久性，可以在系统崩溃或重启后继续运行。

守护进程的一种常见应用是在后台提供网络服务，如 Web 服务器（例如 Apache、Nginx）、数据库服务（如 MySQL、PostgreSQL）等。它们在系统启动时自动启动，并在后台监听网络请求并提供相应的服务。守护进程还可以用于执行定时任务，如系统备份、数据清理等。

守护进程的编写通常需要注意一些细节，比如关闭文件描述符、改变工作目录、重设文件权限等，以确保它们在后台安全、稳定地运行。
```





# 猿辅导

## 01



—位特别有责任心的老师，为了给学生带来高质量的课堂，翻阅了非常多的书籍，最后终于挑出了最有价值的几类书，
并写了一个类目录，每个类用一个小写英文字母代表，比如m代表math.
老师振臂高呼太棒啦，却一不小心把所有书籍散落在了地上，你能帮帮老师统计出每个类下有多少书籍吗？
举例，老师统计的目录为[a,b,m]。散落在地上的书籍为a,a,m,m,b,d,d,x,x。则你应该统计的结果：a 2,b 1,m 2。

[a,m,b]
a,a,m,m,b,d,d,x,x

## 02

教室中间有一条走廊，出口如图，在走廊两旁有几排座位，同学们随意坐在不同的座位上，假设每个单位时间 学生们可以移动距离为1，目同一时间同一个位置只能有一个同学。所有同学的下课出教室路径都是从座位先移动到走廊，然后走到门口即可。
假设走廊是y轴，出口是(0,0)。
输入描述：
输入n代表学生数。后面n行输入，每行2个数字，表示学生坐标x y
输出描述：
输出最短时间t
给我一个Java ACM解法



如果输入为
3
3 4
-3 4
2 3

正确输出为8





## 03

有一个树形的棋盘，棋盘上有n个结点，由n-1条边连接起来，每个结点摆放有黑色或者白色的棋子。
玩家可以选择棋盘上任意两个不同的结点x,y，如果从x出发到达y的最短路径上任意两个相邻的结点都有不同的颜色，
那么玩家就能够将路径上的棋子全部消除掉（包括x，y)。消除掉的节点越多，玩家获得的奖品越丰厚。
为了能消除更多的棋子，允许玩家最多能改变k个棋子的颜色。现在玩家只有一次消除棋子的机会，请问最多能消除掉多少个棋子。

输入描述：
第一行输入两个整数n，k
第二行输入n个整数，其中第i个整数代表编号为i的结点上棋子的颜色（0代表白色 1代表黑色），结点编号从1到n
接下来n-1行，每行2个整数x,y表示结点x,y相连（无向边）,其中1<=x,y<=n

输出描述：
输出一个整数代表最多能消除的棋子数
给我一个Java ACM解法

3 1
0 0 0
1 2
3 

3

4 0
1 1 0 0
2 3
2 4
1 2

3



# 信也 0918

60分钟、20单选 5多选 1问答 2编程

## T1

https://blog.csdn.net/m0_58761900/article/details/126947774





## T2

有一个神奇的背包，总的承重是M，用这个背包可以装下一些物品，这些物品的总重量必须是M。Bob现在有n个想要得到的物品，每个物品的重量分别是a1，a2．．．．．．an，Bob可以从这些物品中选择一些，如果选出的物品的总重量是M，那么利用这个神奇的背包，Bob就可以得到这些物品。现在的问题是，Bob有多少种不同的选择物品的方式。


输入描述：
第一行M表示背包总的承重
第二行正整数n表示不同的物品的数量
接下来n行，每行有一个1到M之间的整数，分别给出a1，a2．．．．．．an的值

ACM java给我一个解法

```sh
40
3
20
20
20
```





```java
import java.util.Scanner;

public class A0918_02 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int M = scanner.nextInt();
        int n = scanner.nextInt();
        int[] a = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            a[i] = scanner.nextInt();
        }

        int[][] dp = new int[n + 1][M + 1];
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= M; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= a[i]) {
                    dp[i][j] += dp[i - 1][j - a[i]];
                }
            }
        }

        System.out.println(dp[n][M]);
    }
}
```





# 掌阅 0918

1.5h、20选择30分、2简答20分、3编程40分

## 简答20分

什么是数据库事务，简述事务ACID特性的含义

什么是死锁，如何避免和解决死锁问题

## T1 长度最小的子数组

leetcode 原题

## T2 背包问题

小阅（掌阅吉祥物）在掌阅应用上有一些阅饼，他可以使用这些阅饼兑换一些书籍。
他想兑换很多，且每本书只需要兑换一次，但由于阅饼有限不能兑换到所有书，因此他将想兑换的每本书设置了1个价值，代表读完该书带来的收益值。
他想请你帮忙计算一下，所总换的书籍价值之和最大是多少

输入描述：
第一行输入s和n，代表有s个阅饼和n本书，s的范围是[1，10000］，n的范围是［1，500］。
接下来n行的每一行有两个数c，v，代表该书需要的阅饼数和价值，c和v的范围是［1，10000］

输出描述：输出兑换书籍的最大值

输入样例：
10 2
7 12 
6 14

输出样例：
14

## T3 智能机器人

小阅（掌阅吉祥物）正在进行一项有趣的测试，以评估机器人在解决迷宫问题上的智能程度。
因此他将机器人放在一个n＊m的迷宫中，看机器人最少需要走多少步到达目的地。

输入描述：
输入包含两行，第一行代表n和m，n和m的范围是［2，2000］，接下来n行，每行包含m个字符，代表迷宫的方格，
包含四种字符：'s'代表机器人出发点，'e'代表机器人终点，'.'代表可通过，'#'代表禁止通过。

输出福述：
输出最短需要时间，如果不能到达则输出—1。

输入示例如下
3 3
.s.
#..
e..

ACM 模式Java给我个解法









# 顺丰 0920



## T1



小红拿到了一个字符串s。她可以进行任意次以下操作：
选择字符串中的一个字母ch1和任意一个字母ch2（ch2可以不在字符串中出现），将字符串s中的所有
ch1变成ch2。
小红想知道，自己能否通过一些操作将字符串s变成t?

输入描述
第一行输入一个正整数q，代表查询次数。
然后每2行代表一次查询：第一行输入一个字符串s。第二行输入一个字符串t。1≤q≤10
保证s和t的长度相同，且均由小写字母组成。长度不超过10000

示例输入
3
ab
ba
abc
aaa
aaaa
abcd

示例输出
Yes
Yes
No

ACM 模式Java给我个解法





## T2

野猪骑士最近在一条路上锻炼，整条路可以被分作n块地块，每个地块有自己的高度hi，
i属于集合｛1，2，3，．．．，n｝．野猪骑士在地块i时，会跳向下标比i大且高度比hi严格大的地块的集合
中高度最小的地块。

野猪骑士希望知道自己在每个地块上的下一跳的目的地的高度，如果下一跳不存在的话，则记为—1。
但这对野猪骑士来说太难了，他希望你来帮助他。

更形式化地说，给定一个数列h，求一个数列d，其中如果｛hj|j＞i＆hj＞hi｝≠Ø，则
di：＝min｛hj｜j＞i＆hj＞hi｝，否则di：＝-1 （其中：＝是赋值符号）。

输入描述:
第一行包括一个正整数n，第二行包含n个正整数h1,h2,....,hn.

输出描述：
一行，包括n个正整数d1,d2,...dn

ACM 模式Java给我个解法

输入示例：
4
4 1 2 3

输出：
-1 2 3 -1







# 携程 0921



游游拿到了一个排列a。她希望你构造一个长度相等的排列b，满足ai≠bi且b的字典序尽可能小。你能帮帮她吗？
所谓排列，即长度为n的数组，其中1到n每个正整数都恰好出现了1次。



输入描述
第一行输入一个正整数n，代表排列a的长度。
第二行输入n个正整数ai，代表游游拿到的排列。

输出描述
n个正整数bi，代表构造的排列。


示例输入
3
1 2 3
示例输出
2 3 1

ACM 模式Java给我个解法





游游拿到了一个n行m列的字母矩阵，矩阵中所有字符都是小写字母。
游游想知道，有多少个子矩阵满足，每个字母最多出现一次？

输入描述
第一行输入两个正整数n和m，代表矩阵的大小。

输出描述
每种字母只出现一次的子矩阵的数量

输入示例
2 3
aad
abc
输出示例
13

ACM 模式Java给我个解法







游游拿到了一个正整数，她准备恰好修改其中k位，使得该正整数变成75的倍数。
你能帮游游求出有多少种修改方案吗？
修改后，仍是正整数，且不允许存在前导零，答案请对10的9次方再加7取模。

输入描述
第一行输入一个正整数n。

输出描述
修改的方案数，对10的9次方再加7取模。

示例输入
355
2
对应输出
9

ACM 模式Java给我个解法





# 美团 0923

小美有一个长度为n的数组a。
如果一个序列b满足对于任意的i≥2，都有bi＝b(i-2)，则这是一个好序列。
小美想知道数组a的子序列中，最长的好序列的长度是多少。

子序列是指在一个序列中去掉一些元素而不改变剩余元素的相对位置所得到的序列。也就是说，如果
一个序列S可以通过去掉其中的一些元素得到另一个序列T，则称T是S的子序列。

输入描述
第一行一个整数n，表示数组a的长度。第二行n个整数，表示数组a的元素。

输出描述 输出一个整数
表示最长的好序列的长度

ACM 模式Java给我个解法


4
1 2 1 2




数列生成规则是：首先是1，然后是2到1，然后是 3 到 1，…………以此类推，每次从k到 1 加入数列然后k自增 1。
如：1,2,1,3,2,1,4,3,2,1,5,4,3,2,1,..
那么数列的前n项和等于多少。你能帮帮她吗？

输入描述
输入一个正整数n

输出描述
一个整数，代表前n项的和。
比如输入4，那么就是数列的前四项，应该输出7，即1,2,1,3的和
由于答案过大，请对10的9次方 + 7取模

ACM 模式Java给我个解法






小美拿到了一个钟表，上面显示的时间格式是＂xx：xx＂，其中，：前面表示小时，后面表示分钟。
时间为24小时制，从00：00到23：59。

现在给定一个初始的时间，以及给定小美对钟表修改的时间量，求最终钟表显示的时间。
小美每次的修改用＂＋x＂或者＂—x＂表示，分别代表时间往后调x分钟、时间往前调x分钟。

输入描述：
第一行输入一个长度为5的字符串，表示初始时间。第二行输入一个正整数n，代表小美的操作次数。
接下来的n行，每行首先输入一个字符ch，代表调整的策略，然后输入一个空格和正整数x，代表调整的分钟数。

输出描述：
一个长度为5的字符串，代表最终时间

ACM 模式Java给我个解法


输入
00.00
2

2

5
输出
00:57






小美这学期一共有n场考试，成绩分别为a1，a2，···，an。
小美想知道从第二场考试到最后一场考试，有多少场考试的成绩低于之前所有考试的最低分，或者高于之前所有考试的最高分。

输入描述:
第一行一个整数n，表示考试场数。
一行n个整数a1，a2，···，an，表示每场考试的成绩。

输出描述：
一行一个整数，表示答案。

ACM 模式Java给我个解法



# 网易

小红有一个长度为n的数组，数组下标为0到n—1，每次可以交换下标为i和（i＋2）％n的数，
请问小红能否通过有限次交换使得数组变成一个单调不减的数组。

输入描述
第一行一个整数t，表示数据组数。
接下来t组数据，每组数据第一行一个整数n，表示数组长度。
每组数据第二行n个整数ai，表示数组的值。1≤t≤10

输出描述 
对于每组数据，如果可以通过有限次交换使得数组变成一个单调不减的数组输出YES，否则输出NO

ACM java给我个解法


2
4
1 4 3 2
4
4 3 2 1
NO








小红拿到了一棵树，她有q次询问，每次会选出一个点集，小红希望你使用尽可能少的简单路径覆盖点
集中的所有节点。你能帮帮她吗？

输入描述
第一行输入两个正整数n和q，代表树的节点数量和小红的询问次数。
接下来的n—1行，每行输入两个正整数u和v，代表节点u和节点v有一条边连接。
接下来的2＊q行，每两行代表一次询问。
每次询问的第一行为一个正整数m，代表点集的大小。第二行为m个正整数ai，代表点集中的节点编号。

输出描述
输出q行，每行输出一个正整数，代表每次询问覆盖点集中所有点的最少路径数量。

示例1
输入
4 2
1 2
1 3
1 4
3
1 2 3
3
2 3 4

输出
1
2 


ACM java给我个解法







1．【算法】编程题：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为Ai（i为n个物品的顺序下标，每个物品只能选择一次且物品大小均为正整数）











# 小米







# 360

## T1

某公司有n名员工，第i名员工具有的能力可以用一个正整数ai描述，称为员工的能力值。
现在，公司有一个项目需要交给恰好［n／2]名员工负责，为了保证项目能顺利进行，要求负责该项目的所有员工能力值之和大于等于x。
公司希望你可以帮忙求出，有多少种不同的派遣员工来负责这个项目的方案。
上文中，［x]表示大于等于x的最小整数，例如［4］＝4，［4.2]＝5，认为两个方案不同，当且仅当存在一名员工在一种方案中负责该项目，而在另一种方案中不负责。

输入描述
输入包含多组数据，输入第一行包含一个整数T，表示数据组数。
接下来2T行，每两行描述了一组数据。
每组数据第一行包含两个正整数n（1≤n≤16）和x分别表示公司的员工总数和项目对负责员工能力值之和的要求。
每组数据第二行包含n个整数，第i个整数表示第i名员工的能力值ai。

输出描述
输出包含T行，对于每组数据输出一行一个整数，表示可行的派遣方案数。

ACM 模式Java给我个解法







## T2

https://blog.csdn.net/qq_38632594/article/details/126822747





```
6
16=1+2*3
7*8*9=54
1+1=1+22
4*6=22+2
15+7=1+2
11+1=1+5
```













# 面试整理

1. 你怎么知道产生了慢查询的情况？索引应该怎么加？

- 慢查询
  - 分析和优化查询语句。避免不必要的连接和子查询。
  - 通过慢查询日志定位。（默认不开启）
  - 用 Explain 查看 SQL 的执行计划（模拟优化器执行查询语句，帮助我们理解查询是如何执行的）
- 加索引
  - 考虑选择合适的列作为索引：选择经常用于筛选、连接或排序的列作为索引。唯一性较高的列（如主键）通常也适合用作索引。
  - 考虑联合索引：如果多个列经常一起出现在查询条件中，可以考虑创建联合索引，以提高查询性能
  - 避免过多的索引：权衡选择合适的索引数量。



2. 既然都是基于内存的，那么es和redis有什么区别

- es以JSON文档形式存储和索引数据。redis以键值对的形式存储数据，并支持丰富的数据类型，如字符串、哈希表、有序集合等。
- 强大的全文搜索和复杂的数据分析功能，ES是一个不错的选择。快速的读写操作和缓存功能，Redis更适合。



3. 数据库本身也有自己的缓存 为什么还要用radis来缓存

- 数据库本身通常具有内置的缓存机制，如MySQL的查询缓存或Oracle的共享池。这些缓存机制可以在一定程度上提高数据库查询性能，减少对磁盘的访问。
- 使用Redis作为独立的缓存层仍然有以下一些优势
  - 更高的性能：Redis是基于内存的键值存储系统，相对于传统磁盘数据库，它具有更快的读写速度和更低的延迟。特别适用于缓存热门数据和频繁查询的数据。
  - 解耦数据库压力：将一部分读请求从数据库转移到Redis中处理



5. 微服务和单体服务有什么区别为什么要把服务拆开如果是为了承载更大的访问量 为什么不考虑做成集群

- 区别
  - 两种不同的架构风格，它们在设计原则和实现方式上存在一些区别。
- 为什么要将服务拆分为微服务呢？
  - 独立开发和部署
  - 可扩展：将扩展的粒度缩小到每个服务
  - 高可用和容错性：实现部分故障隔离和容错。如果一个服务发生故障，其他服务仍然可以正常工作，从而提高整体系统的可用性。
  - 避免JAR冲突
- 为什么不仅仅考虑将单体服务部署为集群，而选择微服务架构
  - 部署和扩展的灵活性：每个服务都可以独立进行部署和扩展。
  - 解耦和隔离
  - 技术栈和工具的选择：每个微服务可以选择适合自身的技术栈和工具。



6. 微服务下数据怎么共享 集群中修改数据怎么保证一致性

- 分布式数据库、一致性协议和分布式锁、各自维护私有数据



7. 用户在请求数据的时候 请求的是哪里的数据是服务器上的吗 怎么保证本地缓存数据和服务器上数据的一致性

- 用户请求数据时，请求的数据可以是存储在服务器上的数据。服务器通常负责处理用户请求，并从存储层（如数据库、文件系统等）获取数据，然后将响应返还给用户。
- 保证本地缓存数据和服务器上数据一致性
  - 失效策略和过期时间。为每个缓存项设置一个合理的过期时间。当缓存项的过期时间到达后，缓存将会自动失效，并通过发送请求到服务器来获取最新数据。
  - 异步更新和延时双写：在进行数据更新时，可以采用异步的方式进行更新。即使服务器上的数据和缓存数据在一段时间内不一致，也可以通过其他的机制（如定期或实时的刷新）来保证数据最终一致性。



9. 代理和反向代理有什么区别代理和适配器模式有什么区别

- 代理模式是为了控制和增强对实际对象的访问，并提供额外的功能。它通过代理对象与客户端进行交互，代表客户端操作真实对象。
- 反向代理是一种网络架构模式，隐藏了服务器并接受客户端的请求，将请求转发给后端的多个服务器。它提供负载均衡、缓存和安全性等功能。Nginx？
- 适配器模式是为了解决不兼容的接口或类之间的问题。它通过适配器将原本不兼容的类转换为目标接口，使其能够协同工作。









## 泰隆银行

1.自我介绍。 

2.根据简历问了实习，包括实习做过的项目介绍。 

3.然后根据这些项目问一些八股，包括并发、事务、redis、springboot、mybatis、spring中的设计模式&应用场景举例、maven、字符流/字节流、IO多路复用，问的比较开放。

 4.反问：问了一下技术栈。 



linux mysql索引、执行计划、数据结构



Java基础 集合 spring的aop MySQL Redis 



比如wait和sleep 的区别； 聚簇索引和非聚簇索引

一个是最小花费爬楼梯，一个是反转字符串。





如何远程调试

```
保证本地代码和服务器代码一致
服务添加启动参数开发特定端口
通过指定端口连接远程服务
添加断点、接口请求
调试
```

1.set
2.set元素为什么不重复？
3.String StringBuffer StringBuilder
4.重写与重载
5.wait与sleep









1.set和 list的区别

2.为什么hashset是不可重复集合，底层实现

3.hashmap为什么线程不安全

4.hashmap底层原理

5.concurrent hashmap底层原理

6.介绍一下redis以及项目中的使用

7.怎样使用redis命令进行模糊查询

8.sql怎么优化

9.索引失效场景

10.面向对象程序的设计原则

11.spring中使用到的设计模式

12.springaop动态代理有哪几种形式

13.jvm内存结构





































